var paddle=paddle||{},protobuf=protobuf||require("./protobuf"),base=base||require("./base");paddle.ModelFactory=class{match(t){const e=t.identifier,a=e.split(".").pop().toLowerCase();return"__model__"==e||"paddle"==a||"pdmodel"==a}open(t,e){return e.require("./paddle-proto").then(()=>{let a=null;const s=t.identifier;try{paddle.proto=protobuf.get("paddle").paddle.framework.proto;const e=protobuf.Reader.create(t.buffer);a=paddle.proto.ProgramDesc.decode(e)}catch(t){throw new paddle.Error("File format is not paddle.ProgramDesc ("+t.message+") in '"+s+"'.")}return paddle.Metadata.open(e).then(t=>{try{return new paddle.Model(t,a)}catch(t){throw e.exception(t,!1),new paddle.Error(t.message)}})})}},paddle.Model=class{constructor(t,e){this._graphs=[];for(const a of e.blocks)this._graphs.push(new paddle.Graph(t,a))}get graphs(){return this._graphs}get format(){return"PaddlePaddle"}},paddle.Graph=class{constructor(t,e){this._nodes=[],this._inputs=[],this._outputs=[];const a={},s={};for(const t of e.vars)t.persistable&&t.type&&t.type.type!=paddle.proto.VarType.Type.FETCH_LIST&&t.type.type!=paddle.proto.VarType.Type.FEED_MINIBATCH?a[t.name]=new paddle.Tensor(t):s[t.name]=paddle.Graph._type(t);const r={};for(let t=0;t<e.ops.length;t++){for(const a of e.ops[t].inputs)a.arguments=a.arguments.map(t=>r[t]?r[t]:t);for(const a of e.ops[t].outputs)a.arguments=a.arguments.map(e=>{if(r[e]){const a=e+"\n"+t.toString();return r[e]=a,a}return r[e]=e,e})}let n=null,p=null;for(const r of e.ops)if("feed"==r.type){const t=r.attrs.filter(t=>"col"==t.name)[0].i.toString();this._inputs.push(new paddle.Parameter(t,r.outputs[0].arguments.map(t=>new paddle.Argument(t,s[t],null,null))))}else if("fetch"==r.type){const t=r.attrs.filter(t=>"col"==t.name)[0].i.toString();this._outputs.push(new paddle.Parameter(t,r.inputs[0].arguments.map(t=>new paddle.Argument(t,s[t],null,null))))}else{const e=new paddle.Node(t,r,a,s);1==r.inputs.length&&1==r.inputs[0].arguments.length&&r.outputs.length>=1&&1==r.outputs[0].arguments.length&&r.inputs[0].arguments[0].split("\n").shift()==r.outputs[0].arguments[0].split("\n").shift()&&n&&p==r.inputs[0].arguments[0].split("\n").shift()?n.chain.push(e):(this._nodes.push(e),n=null,p=null,1==r.outputs.length&&1==r.outputs[0].arguments.length&&(n=e,p=r.outputs[0].arguments[0].split("\n").shift()))}}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}static _type(t){switch(t.type.type){case paddle.proto.VarType.Type.LOD_TENSOR:if(t.type.lod_tensor)return new paddle.TensorType(t.type.lod_tensor.tensor)}return null}},paddle.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},paddle.Argument=class{constructor(t,e,a,s){if("string"!=typeof t)throw new paddle.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e||null,this._description=a||null,this._initializer=s||null}get name(){return this._name}get type(){return this._type?this._type:this._initializer?this._initializer.type:null}get description(){return this._description}get initializer(){return this._initializer}},paddle.Node=class{constructor(t,e,a,s){this._metadata=t,this._type=e.type,this._attributes=[],this._inputs=[],this._outputs=[],this._chain=[];for(const a of e.attrs){const e=t.attribute(this._type,this._name);this._attributes.push(new paddle.Attribute(e,a))}for(const t of e.inputs)if(t.arguments.length>0){const e=t.arguments.map(t=>new paddle.Argument(t,s[t.split("\n").shift()],null,a[t]));this._inputs.push(new paddle.Parameter(t.parameter,e))}for(const t of e.outputs)if(t.arguments.length>0){const e=t.arguments.map(t=>new paddle.Argument(t,s[t.split("\n").shift()],null,null));this._outputs.push(new paddle.Parameter(t.parameter,e))}this._update(this._inputs,"X"),this._update(this._inputs,"Input"),this._update(this._outputs,"Y"),this._update(this._outputs,"Out")}get type(){return this._type}get name(){return""}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chain}_update(t,e){let a=null;for(let s=0;s<t.length;s++)if(t[s].name==e){a=t[s],t.splice(s,1);break}a&&t.splice(0,0,a)}},paddle.Attribute=class{constructor(t,e){switch(this._name=e.name,this._value="?",e.type){case paddle.proto.AttrType.STRING:this._type="string",this._value=e.s;break;case paddle.proto.AttrType.STRINGS:this._type="string[]",this._value=e.strings;break;case paddle.proto.AttrType.BOOLEAN:this._type="boolean",this._value=e.b;break;case paddle.proto.AttrType.BOOLEANS:this._type="boolean[]",this._value=e.bools;break;case paddle.proto.AttrType.FLOAT:this._type="float32",this._value=e.f;break;case paddle.proto.AttrType.FLOATS:this._type="float[]",this._value=e.floats;break;case paddle.proto.AttrType.INT:this._type="int32",this._value=e.i;break;case paddle.proto.AttrType.INTS:this._type="int32[]",this._value=e.ints;break;case paddle.proto.AttrType.LONG:this._type="int64";break;case paddle.proto.AttrType.LONGS:this._type="int64[]"}switch(this._name){case"use_mkldnn":case"use_cudnn":case"op_callstack":case"op_role":case"op_role_var":case"op_namescope":case"is_test":this._visible=!1}if(t&&Object.prototype.hasOwnProperty.call(t,"default")){const e=t.default,a=this._value;(e==a||Array.isArray(a)&&Array.isArray(e)&&a.length==e.length&&a.every((t,a)=>t==e[a]))&&(this._visible=!1)}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},paddle.Tensor=class{constructor(t){this._type=paddle.Graph._type(t)}get type(){return this._type}get state(){return"Tensor data not implemented."}get value(){return null}toString(){return""}},paddle.TensorType=class{constructor(t){switch(t.data_type){case paddle.proto.VarType.Type.INT32:this._dataType="int32";break;case paddle.proto.VarType.Type.INT64:this._dataType="int64";break;case paddle.proto.VarType.Type.FP32:this._dataType="float32";break;case paddle.proto.VarType.Type.FP64:this._dataType="float64";break;default:this._dataType="?"}this._shape=new paddle.TensorShape(t.dims)}get dataType(){return this._dataType}get shape(){return this._shape}get denotation(){return this._denotation}toString(){return this.dataType+this._shape.toString()}},paddle.TensorShape=class{constructor(t){this._dimensions=t.map(t=>-1!=t?t:"?")}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length?"["+this._dimensions.join(",")+"]":""}},paddle.Metadata=class{static open(t){return paddle.Metadata._metadata?Promise.resolve(paddle.Metadata._metadata):t.request(null,"paddle-metadata.json","utf-8").then(t=>(paddle.Metadata._metadata=new paddle.Metadata(t),paddle.Metadata._metadata)).catch(()=>(paddle.Metadata._metadata=new paddle.Metadata(null),paddle.Metadata._metadata))}constructor(t){if(this._map={},this._attributeCache={},t){const e=JSON.parse(t);if(e)for(const t of e)t.schema.name=t.name,this._map[t.name]=t.schema}}type(t){return this._map[t]||null}attribute(t,e){let a=this._attributeCache[t];if(!a){a={};const e=this.type(t);if(e&&e.attributes&&e.attributes.length>0)for(const t of e.attributes)a[t.name]=t;this._attributeCache[t]=a}return a[e]||null}},paddle.Error=class extends Error{constructor(t){super(t),this.name="Error loading PaddlePaddle model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=paddle.ModelFactory);