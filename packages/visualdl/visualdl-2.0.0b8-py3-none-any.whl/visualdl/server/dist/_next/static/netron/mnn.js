var mnn=mnn||{},base=base||require("./base"),flatbuffers=flatbuffers||require("flatbuffers").flatbuffers;mnn.ModelFactory=class{match(t){return"mnn"==t.identifier.split(".").pop().toLowerCase()}open(t,e){return e.require("./mnn-schema").then(n=>mnn.Metadata.open(e).then(s=>{const a=t.identifier;try{mnn.schema=n.mnn_schema;const e=new flatbuffers.ByteBuffer(t.buffer),a=mnn.schema.Net.getRootAsNet(e);return new mnn.Model(s,a)}catch(t){e.exception(t,!1);const n=t&&t.message?t.message:t.toString();throw new mnn.Error(n.replace(/\.$/,"")+" in '"+a+"'.")}}))}},mnn.Model=class{constructor(t,e){switch(e.sourceType()){case mnn.schema.NetSource.CAFFE:this._source="Caffe";break;case mnn.schema.NetSource.TENSORFLOW:this._source="TensorFlow";break;case mnn.schema.NetSource.TFLITE:this._source="TensorFlow Lite";break;case mnn.schema.NetSource.ONNX:this._source="ONNX"}this._graphs=[new mnn.Graph(t,e)]}get format(){return"MNN v2"}get source(){return this._source||""}get graphs(){return this._graphs}},mnn.Graph=class{constructor(t,e){this._nodes=[],this._inputs=[],this._outputs=[];const n=new Set;for(let s=0;s<e.oplistsLength();s++){const a=e.oplists(s);if("Input"===mnn.schema.OpTypeName[a.type()]){const t=[];for(let n=0;n<a.outputIndexesLength();n++){const s=a.outputIndexes(n),r=e.tensorName(s),i=e.extraTensorDescribe(s),o=i?i.blob():null,u=o?mnn.Graph._blobTensorType(o):null;t.push(new mnn.Argument(r,u,null))}this._inputs.push(new mnn.Parameter(a.name(),!0,t))}else this._nodes.push(new mnn.Node(t,a,e));for(let t=0;t<a.inputIndexesLength();t++){const e=a.inputIndexes(t);n.add(e)}}for(let t=0;t<e.tensorNameLength();t++)if(!n.has(t)){const n=e.tensorName(t),s=e.extraTensorDescribe(t),a=s?s.blob():null,r=a?mnn.Graph._blobTensorType(a):null;this._outputs.push(new mnn.Parameter(n,!0,[new mnn.Argument(n,r,null)]))}}get name(){return""}get groups(){return!1}get nodes(){return this._nodes}get outputs(){return this._outputs}get inputs(){return this._inputs}static _blobTensorType(t){mnn.Graph._blobTensorTypeMap=mnn.Graph._blobTensorTypeMap||new Map([[mnn.schema.DataType.DT_INVALID,"?"],[mnn.schema.DataType.DT_FLOAT,"float32"],[mnn.schema.DataType.DT_DOUBLE,"float64"],[mnn.schema.DataType.DT_INT32,"int32"],[mnn.schema.DataType.DT_UINT8,"uint8"],[mnn.schema.DataType.DT_INT16,"int16"],[mnn.schema.DataType.DT_INT8,"int8"],[mnn.schema.DataType.DT_STRING,"string"],[mnn.schema.DataType.DT_COMPLEX64,"complex64"],[mnn.schema.DataType.DT_INT64,"int64"],[mnn.schema.DataType.DT_BOOL,"boolean"],[mnn.schema.DataType.DT_QINT8,"qint8"],[mnn.schema.DataType.DT_QUINT8,"quint8"],[mnn.schema.DataType.DT_QINT32,"qint32"],[mnn.schema.DataType.DT_BFLOAT16,"bfloat16"],[mnn.schema.DataType.DT_QINT16,"qint16"],[mnn.schema.DataType.DT_QUINT16,"quint16"],[mnn.schema.DataType.DT_UINT16,"uint16"],[mnn.schema.DataType.DT_COMPLEX128,"complex128"],[mnn.schema.DataType.DT_HALF,"float16"],[mnn.schema.DataType.DT_RESOURCE,"resource"],[mnn.schema.DataType.DT_VARIANT,"variant"]]);const e=mnn.Graph._blobTensorTypeMap.has(t.dataType())?mnn.Graph._blobTensorTypeMap.get(t.dataType()):"?",n=t.dimsArray()||[];return new mnn.TensorType(e,new mnn.TensorShape(n))}},mnn.Node=class{constructor(t,e,n){this._metadata=t,this._type=mnn.schema.OpTypeName[e.type()]||"("+e.type().toString()+")",this._name=e.name()||"",this._attributes=[],this._inputs=[],this._outputs=[],this._chains=[];const s=[];for(let t=0;t<e.inputIndexesLength();t++){const a=e.inputIndexes(t),r=n.tensorName(a);s.push(new mnn.Argument(r,null,null))}this._inputs.push(new mnn.Parameter("input",!0,s));const a=[];for(let t=0;t<e.outputIndexesLength();t++){const s=e.outputIndexes(t),r=n.tensorName(s);a.push(new mnn.Argument(r,null,null))}this._outputs.push(new mnn.Parameter("output",!0,a));const r=mnn.schema.OpParameterName[e.mainType()],i=mnn.schema[r];if("function"==typeof i){const s=e.main(Reflect.construct(i,[]));if(null!==s&&s instanceof mnn.schema.Blob){const t=mnn.Graph._blobTensorType(s);let e=null;switch(t.dataType){case"int32":e=s.int32sArray();break;case"float32":e=s.float32sArray()}this._inputs.push(new mnn.Parameter("value",!0,[new mnn.Argument("",null,new mnn.Tensor("Blob",t,e))]))}else{let e=null;switch(r){case"Convolution2D":{const t=s.common(),n=t.outputCount(),a=t.inputCount(),r=t.kernelX(),i=t.kernelY();this._buildTensor("float32","weight",[n,a,r,i],s.weightArray()),this._buildTensor("float32","bias",[n],s.biasArray()),e={weight:!0,bias:!0};break}case"InnerProduct":{const t=s.outputCount(),n=s.weightSize()/t;this._buildTensor("float32","weight",[t,n],s.weightArray()),this._buildTensor("float32","bias",[t],s.biasArray()),e={weight:!0,bias:!0};break}case"Scale":{const t=s.channels();this._buildTensor("float32","scale",[t],s.scaleDataArray()),this._buildTensor("float32","bias",[t],s.biasDataArray()),e={scaleData:!0,biasData:!0};break}case"BatchNorm":{const t=s.channels();this._buildTensor("float32","mean",[t],s.meanDataArray()),this._buildTensor("float32","slope",[t],s.slopeDataArray()),this._buildTensor("float32","variance",[t],s.varDataArray()),this._buildTensor("float32","bias",[t],s.biasDataArray()),e={slopeData:!0,meanData:!0,varData:!0,biasData:!0};break}case"PRelu":this._buildTensor("float32","slope",[s.slopeCount()],s.slopeArray()),e={slope:!0};break;case"Normalize":this._buildTensor("float32","scale",[s.scaleLength()],s.scaleArray()),e={scale:!0}}this._recursivelyBuildAttributes(t,n,s,r,e,this._attributes)}}}_buildTensor(t,e,n,s){this._inputs.push(new mnn.Parameter(e,!0,[new mnn.Argument("",null,new mnn.Tensor("Weight",new mnn.TensorType(t,new mnn.TensorShape(n)),s))]))}_recursivelyBuildAttributes(t,e,n,s,a,r){if(!n)return;let i=[];const o={};for(const t of Object.keys(Object.getPrototypeOf(n)))"__init"!=t&&i.push(t),o[t]=!0;const u={};for(const t of Object.keys(o))o[t+"Length"]&&(u[t]=!0,i=i.filter(e=>e!=t+"Array"&&e!=t+"Length"));for(const s of i)if((!a||!a[s])&&n[s]&&"function"==typeof n[s]){let a=null;if(u[s]){const t=[],e=n[s+"Length"]();for(let a=0;a<e;a++)t.push(n[s](a));a=t}else if(a=n[s](),"object"==typeof a){let n=null;for(const t of Object.getOwnPropertyNames(mnn.schema)){const e=mnn.schema[t];if("function"==typeof e&&a instanceof e){n=t;break}}this._recursivelyBuildAttributes(t,e,a,n,null,r),a=null}if(null!=a){const e=t.attribute(this.type,s);r.push(new mnn.Attribute(e,s,a))}}}get type(){return this._type}get name(){return this._name}get domain(){return null}get metadata(){return this._metadata.type(this.type)}get group(){return null}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chains}get attributes(){return this._attributes}},mnn.Attribute=class{constructor(t,e,n,s){if(this._type=null,this._value=n,this._name=e,this._visible=s,t&&t.type){this._type=t.type;const e=mnn.schema[this._type+"Name"];e&&(this._value=e[this._value])}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},mnn.Parameter=class{constructor(t,e,n){this._name=t,this._visible=e,this._arguments=n}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},mnn.Argument=class{constructor(t,e,n){this._name=t,this._type=e||null,this._initializer=n||null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},mnn.Tensor=class{constructor(t,e,n){this._kind=t,this._type=e,this._data=n}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={state:null};return this._data?(t.index=0,t.count=0,t.dataType=this._type.dataType,t.dimensions=this._type.shape.dimensions,t.data=this._dataType,t):(t.state="Tensor data is empty.",t)}_decode(t,e){let n=t.dimensions;0==n.length&&(n=[1]);const s=[],a=n[e];if(e==n.length-1)for(let e=0;e<a;e++){if(t.count>t.limit)return s.push("..."),s;s.push(this._data[t.index]),t.index++,t.count++}else for(let n=0;n<a;n++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,e+1))}return 0==t.dimensions.length?s[0]:s}},mnn.TensorType=class{constructor(t,e){this._dataType=t||"?",this._shape=e}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},mnn.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length>0?"["+this._dimensions.map(t=>t?t.toString():"?").join(",")+"]":""}},mnn.Metadata=class{static open(t){return mnn.Metadata._metadata?Promise.resolve(mnn.Metadata._metadata):t.request(null,"mnn-metadata.json","utf-8").then(t=>(mnn.Metadata._metadata=new mnn.Metadata(t),mnn.Metadata._metadata)).catch(()=>(mnn.Metadata._metadata=new mnn.Metadata(null),mnn.Metadata._metadata))}constructor(t){if(this._map=new Map,t){const e=JSON.parse(t);if(e)for(const t of e)t.name&&t.schema&&(t.schema.name=t.name,this._map.set(t.name,t.schema))}}type(t){return this._map.has(t)?this._map.get(t):null}attribute(t,e){const n=this.type(t);if(n){let t=n.attributeMap;if(!t){if(t={},n.attributes)for(const e of n.attributes)t[e.name]=e;n.attributeMap=t}const s=t[e];if(s)return s}return null}},mnn.Error=class extends Error{constructor(t){super(t),this.name="Error loading MNN model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=mnn.ModelFactory);