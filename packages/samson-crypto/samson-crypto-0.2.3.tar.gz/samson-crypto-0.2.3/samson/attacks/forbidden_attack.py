from samson.utilities.bytes import Bytes
from samson.math.algebra.all import FF, ZZ
from samson.math.polynomial import Polynomial
from samson.math.symbols import Symbol

x = Symbol('x')
_ = (ZZ/ZZ(2))[x]
F = FF(2, 128, reducing_poly=x**128 + x**7 + x**2 + x + 1)

def int_to_elem(a):
    return F([int(bit) for bit in bin(a)[2:].zfill(128)])

def elem_to_int(a):
    return int(bin(int(a))[2:].zfill(128)[::-1], 2)

def gcm_to_poly(ad, ciphertext, tag):
    l = (len(ad) << (3 + 64)) | (len(ciphertext) << 3)

    ct_ints = [chunk.int() for chunk in ciphertext.pad_congruent_right(16).chunk(16)[::-1]]
    ad_ints = [chunk.int() for chunk in ad.pad_congruent_right(16).chunk(16)[::-1]]

    return Polynomial([int_to_elem(coeff) for coeff in [tag.int(), l, *ct_ints, *ad_ints]])


class ForbiddenAttack(object):
    """
    Performs a authentication key-recovery attack on GCM.

    When using GCM, implementors have to be careful not to reuse nonces with the same key.
    Given two ciphertexts encrypted using the same nonce and key, an attacker can factor
    the authentication key `H`. Using the nonce, recovered keystream, and authentication key,
    they can then forge messages.

    Conditions:
        * GCM is being used
        * The user has access to two GCM ciphertexts encrypted with the same nonce
    """

    def __init__(self):
        pass


    def execute(self, auth_data_a: bytes, ciphertext_a: bytes, tag_a: bytes, auth_data_b: bytes, ciphertext_b: bytes, tag_b: bytes) -> Bytes:
        """
        Executes the attack.
        
        Parameters:
            ciphertext (bytes): Bytes-like ciphertext generated by the system.

        Returns:
            Bytes: The key to the cipher.
        """
        auth_data_a, ciphertext_a, tag_a, auth_data_b, ciphertext_b, tag_b = [Bytes.wrap(item) for item in [auth_data_a, ciphertext_a, tag_a, auth_data_b, ciphertext_b, tag_b]]
        poly_a = gcm_to_poly(auth_data_a, ciphertext_a, tag_a)
        poly_b = gcm_to_poly(auth_data_b, ciphertext_b, tag_b)

        # 3 is the smallest factor of (2**128) - 1
        factors = (poly_a + poly_b).factor(subgroup_divisor=3)

        return [elem_to_int(candidate.coeffs[0]) for candidate in factors if candidate.degree() == 1]
