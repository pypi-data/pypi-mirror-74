"""
# Welcome to `cdk-spot-one`

EC2 Spot Block with Single Instance and EIP

# Sample

Create a single EC2 spot instance for 6 hours with EIP attached:

```python
# Example automatically generated without compilation. See https://github.com/aws/jsii/issues/826
from cdk_spot_one import SpotFleet

fleet = SpotFleet(stack, "SpotFleet",
    target_capacity=1,
    instance_interruption_behavior=InstanceInterruptionBehavior.HIBERNATE,
    default_instance_type=ec2.InstanceType("c5.large"),
    eip_allocation_id="eipalloc-0d1bc6d85895a5410",
    vpc_subnet={
        "subnet_type": ec2.SubnetType.PUBLIC
    },
    terminate_instances_with_expiration=True
)

# fleet to expire after 6 hours
fleet.expire_after(Duration.hours(6))
```
"""
import abc
import builtins
import datetime
import enum
import typing

import jsii
import jsii.compat
import publication

from ._jsii import *

import aws_cdk.aws_ec2
import aws_cdk.aws_iam
import aws_cdk.core


@jsii.data_type(
    jsii_type="cdk-spot-one.BaseSpotFleetProps",
    jsii_struct_bases=[aws_cdk.core.ResourceProps],
    name_mapping={
        "physical_name": "physicalName",
        "block_duration": "blockDuration",
        "bootstrap_enabled": "bootstrapEnabled",
        "custom_ami_id": "customAmiId",
        "default_instance_type": "defaultInstanceType",
        "instance_interruption_behavior": "instanceInterruptionBehavior",
        "instance_role": "instanceRole",
        "map_role": "mapRole",
        "target_capacity": "targetCapacity",
        "terminate_instances_with_expiration": "terminateInstancesWithExpiration",
        "valid_from": "validFrom",
        "valid_until": "validUntil",
        "vpc_subnet": "vpcSubnet",
    },
)
class BaseSpotFleetProps(aws_cdk.core.ResourceProps):
    def __init__(
        self,
        *,
        physical_name: typing.Optional[str] = None,
        block_duration: typing.Optional["BlockDuration"] = None,
        bootstrap_enabled: typing.Optional[bool] = None,
        custom_ami_id: typing.Optional[str] = None,
        default_instance_type: typing.Optional[aws_cdk.aws_ec2.InstanceType] = None,
        instance_interruption_behavior: typing.Optional[
            "InstanceInterruptionBehavior"
        ] = None,
        instance_role: typing.Optional[aws_cdk.aws_iam.Role] = None,
        map_role: typing.Optional[bool] = None,
        target_capacity: typing.Optional[jsii.Number] = None,
        terminate_instances_with_expiration: typing.Optional[bool] = None,
        valid_from: typing.Optional[str] = None,
        valid_until: typing.Optional[str] = None,
        vpc_subnet: typing.Optional[aws_cdk.aws_ec2.SubnetSelection] = None,
    ) -> None:
        """
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param block_duration: 
        :param bootstrap_enabled: 
        :param custom_ami_id: 
        :param default_instance_type: 
        :param instance_interruption_behavior: 
        :param instance_role: 
        :param map_role: 
        :param target_capacity: 
        :param terminate_instances_with_expiration: 
        :param valid_from: 
        :param valid_until: 
        :param vpc_subnet: 

        stability
        :stability: experimental
        """
        if isinstance(vpc_subnet, dict):
            vpc_subnet = aws_cdk.aws_ec2.SubnetSelection(**vpc_subnet)
        self._values = {}
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if block_duration is not None:
            self._values["block_duration"] = block_duration
        if bootstrap_enabled is not None:
            self._values["bootstrap_enabled"] = bootstrap_enabled
        if custom_ami_id is not None:
            self._values["custom_ami_id"] = custom_ami_id
        if default_instance_type is not None:
            self._values["default_instance_type"] = default_instance_type
        if instance_interruption_behavior is not None:
            self._values[
                "instance_interruption_behavior"
            ] = instance_interruption_behavior
        if instance_role is not None:
            self._values["instance_role"] = instance_role
        if map_role is not None:
            self._values["map_role"] = map_role
        if target_capacity is not None:
            self._values["target_capacity"] = target_capacity
        if terminate_instances_with_expiration is not None:
            self._values[
                "terminate_instances_with_expiration"
            ] = terminate_instances_with_expiration
        if valid_from is not None:
            self._values["valid_from"] = valid_from
        if valid_until is not None:
            self._values["valid_until"] = valid_until
        if vpc_subnet is not None:
            self._values["vpc_subnet"] = vpc_subnet

    @builtins.property
    def physical_name(self) -> typing.Optional[str]:
        """The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        default
        :default: - The physical name will be allocated by CloudFormation at deployment time
        """
        return self._values.get("physical_name")

    @builtins.property
    def block_duration(self) -> typing.Optional["BlockDuration"]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("block_duration")

    @builtins.property
    def bootstrap_enabled(self) -> typing.Optional[bool]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("bootstrap_enabled")

    @builtins.property
    def custom_ami_id(self) -> typing.Optional[str]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("custom_ami_id")

    @builtins.property
    def default_instance_type(self) -> typing.Optional[aws_cdk.aws_ec2.InstanceType]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("default_instance_type")

    @builtins.property
    def instance_interruption_behavior(
        self,
    ) -> typing.Optional["InstanceInterruptionBehavior"]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("instance_interruption_behavior")

    @builtins.property
    def instance_role(self) -> typing.Optional[aws_cdk.aws_iam.Role]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("instance_role")

    @builtins.property
    def map_role(self) -> typing.Optional[bool]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("map_role")

    @builtins.property
    def target_capacity(self) -> typing.Optional[jsii.Number]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("target_capacity")

    @builtins.property
    def terminate_instances_with_expiration(self) -> typing.Optional[bool]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("terminate_instances_with_expiration")

    @builtins.property
    def valid_from(self) -> typing.Optional[str]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("valid_from")

    @builtins.property
    def valid_until(self) -> typing.Optional[str]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("valid_until")

    @builtins.property
    def vpc_subnet(self) -> typing.Optional[aws_cdk.aws_ec2.SubnetSelection]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("vpc_subnet")

    def __eq__(self, rhs) -> bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs) -> bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BaseSpotFleetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-spot-one.BlockDuration")
class BlockDuration(enum.Enum):
    """
    stability
    :stability: experimental
    """

    ONE_HOUR = "ONE_HOUR"
    """
    stability
    :stability: experimental
    """
    TWO_HOURS = "TWO_HOURS"
    """
    stability
    :stability: experimental
    """
    THREE_HOURS = "THREE_HOURS"
    """
    stability
    :stability: experimental
    """
    FOUR_HOURS = "FOUR_HOURS"
    """
    stability
    :stability: experimental
    """
    FIVE_HOURS = "FIVE_HOURS"
    """
    stability
    :stability: experimental
    """
    SIX_HOURS = "SIX_HOURS"
    """
    stability
    :stability: experimental
    """


@jsii.interface(jsii_type="cdk-spot-one.ILaunchtemplate")
class ILaunchtemplate(jsii.compat.Protocol):
    """
    stability
    :stability: experimental
    """

    @builtins.staticmethod
    def __jsii_proxy_class__():
        return _ILaunchtemplateProxy

    @jsii.member(jsii_name="bind")
    def bind(self, spotfleet: "SpotFleet") -> "SpotFleetLaunchTemplateConfig":
        """
        :param spotfleet: -

        stability
        :stability: experimental
        """
        ...


class _ILaunchtemplateProxy:
    """
    stability
    :stability: experimental
    """

    __jsii_type__ = "cdk-spot-one.ILaunchtemplate"

    @jsii.member(jsii_name="bind")
    def bind(self, spotfleet: "SpotFleet") -> "SpotFleetLaunchTemplateConfig":
        """
        :param spotfleet: -

        stability
        :stability: experimental
        """
        return jsii.invoke(self, "bind", [spotfleet])


@jsii.enum(jsii_type="cdk-spot-one.InstanceInterruptionBehavior")
class InstanceInterruptionBehavior(enum.Enum):
    """
    stability
    :stability: experimental
    """

    HIBERNATE = "HIBERNATE"
    """
    stability
    :stability: experimental
    """
    STOP = "STOP"
    """
    stability
    :stability: experimental
    """
    TERMINATE = "TERMINATE"
    """
    stability
    :stability: experimental
    """


@jsii.implements(ILaunchtemplate)
class LaunchTemplate(metaclass=jsii.JSIIMeta, jsii_type="cdk-spot-one.LaunchTemplate"):
    """
    stability
    :stability: experimental
    """

    def __init__(self) -> None:
        jsii.create(LaunchTemplate, self, [])

    @jsii.member(jsii_name="bind")
    def bind(self, spotfleet: "SpotFleet") -> "SpotFleetLaunchTemplateConfig":
        """
        :param spotfleet: -

        stability
        :stability: experimental
        """
        return jsii.invoke(self, "bind", [spotfleet])


class SpotFleet(
    aws_cdk.core.Resource, metaclass=jsii.JSIIMeta, jsii_type="cdk-spot-one.SpotFleet"
):
    """
    stability
    :stability: experimental
    """

    def __init__(
        self,
        scope: aws_cdk.core.Construct,
        id: str,
        *,
        eip_allocation_id: typing.Optional[str] = None,
        launch_template: typing.Optional["ILaunchtemplate"] = None,
        block_duration: typing.Optional["BlockDuration"] = None,
        bootstrap_enabled: typing.Optional[bool] = None,
        custom_ami_id: typing.Optional[str] = None,
        default_instance_type: typing.Optional[aws_cdk.aws_ec2.InstanceType] = None,
        instance_interruption_behavior: typing.Optional[
            "InstanceInterruptionBehavior"
        ] = None,
        instance_role: typing.Optional[aws_cdk.aws_iam.Role] = None,
        map_role: typing.Optional[bool] = None,
        target_capacity: typing.Optional[jsii.Number] = None,
        terminate_instances_with_expiration: typing.Optional[bool] = None,
        valid_from: typing.Optional[str] = None,
        valid_until: typing.Optional[str] = None,
        vpc_subnet: typing.Optional[aws_cdk.aws_ec2.SubnetSelection] = None,
        physical_name: typing.Optional[str] = None,
    ) -> None:
        """
        :param scope: -
        :param id: -
        :param eip_allocation_id: 
        :param launch_template: 
        :param block_duration: 
        :param bootstrap_enabled: 
        :param custom_ami_id: 
        :param default_instance_type: 
        :param instance_interruption_behavior: 
        :param instance_role: 
        :param map_role: 
        :param target_capacity: 
        :param terminate_instances_with_expiration: 
        :param valid_from: 
        :param valid_until: 
        :param vpc_subnet: 
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time

        stability
        :stability: experimental
        """
        props = SpotFleetProps(
            eip_allocation_id=eip_allocation_id,
            launch_template=launch_template,
            block_duration=block_duration,
            bootstrap_enabled=bootstrap_enabled,
            custom_ami_id=custom_ami_id,
            default_instance_type=default_instance_type,
            instance_interruption_behavior=instance_interruption_behavior,
            instance_role=instance_role,
            map_role=map_role,
            target_capacity=target_capacity,
            terminate_instances_with_expiration=terminate_instances_with_expiration,
            valid_from=valid_from,
            valid_until=valid_until,
            vpc_subnet=vpc_subnet,
            physical_name=physical_name,
        )

        jsii.create(SpotFleet, self, [scope, id, props])

    @jsii.member(jsii_name="expireAfter")
    def expire_after(self, duration: aws_cdk.core.Duration) -> None:
        """
        :param duration: -

        stability
        :stability: experimental
        """
        return jsii.invoke(self, "expireAfter", [duration])

    @builtins.property
    @jsii.member(jsii_name="defaultInstanceType")
    def default_instance_type(self) -> aws_cdk.aws_ec2.InstanceType:
        """
        stability
        :stability: experimental
        """
        return jsii.get(self, "defaultInstanceType")

    @builtins.property
    @jsii.member(jsii_name="instanceRole")
    def instance_role(self) -> aws_cdk.aws_iam.IRole:
        """
        stability
        :stability: experimental
        """
        return jsii.get(self, "instanceRole")

    @builtins.property
    @jsii.member(jsii_name="launchTemplate")
    def launch_template(self) -> "ILaunchtemplate":
        """
        stability
        :stability: experimental
        """
        return jsii.get(self, "launchTemplate")

    @builtins.property
    @jsii.member(jsii_name="spotFleetId")
    def spot_fleet_id(self) -> str:
        """
        stability
        :stability: experimental
        """
        return jsii.get(self, "spotFleetId")

    @builtins.property
    @jsii.member(jsii_name="targetCapacity")
    def target_capacity(self) -> typing.Optional[jsii.Number]:
        """
        stability
        :stability: experimental
        """
        return jsii.get(self, "targetCapacity")

    @builtins.property
    @jsii.member(jsii_name="validUntil")
    def valid_until(self) -> typing.Optional[str]:
        """
        stability
        :stability: experimental
        """
        return jsii.get(self, "validUntil")

    @valid_until.setter
    def valid_until(self, value: typing.Optional[str]) -> None:
        jsii.set(self, "validUntil", value)


@jsii.data_type(
    jsii_type="cdk-spot-one.SpotFleetLaunchTemplateConfig",
    jsii_struct_bases=[],
    name_mapping={"launch_template": "launchTemplate", "spotfleet": "spotfleet"},
)
class SpotFleetLaunchTemplateConfig:
    def __init__(
        self, *, launch_template: "ILaunchtemplate", spotfleet: "SpotFleet"
    ) -> None:
        """
        :param launch_template: 
        :param spotfleet: 

        stability
        :stability: experimental
        """
        self._values = {
            "launch_template": launch_template,
            "spotfleet": spotfleet,
        }

    @builtins.property
    def launch_template(self) -> "ILaunchtemplate":
        """
        stability
        :stability: experimental
        """
        return self._values.get("launch_template")

    @builtins.property
    def spotfleet(self) -> "SpotFleet":
        """
        stability
        :stability: experimental
        """
        return self._values.get("spotfleet")

    def __eq__(self, rhs) -> bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs) -> bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SpotFleetLaunchTemplateConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-spot-one.SpotFleetProps",
    jsii_struct_bases=[BaseSpotFleetProps],
    name_mapping={
        "physical_name": "physicalName",
        "block_duration": "blockDuration",
        "bootstrap_enabled": "bootstrapEnabled",
        "custom_ami_id": "customAmiId",
        "default_instance_type": "defaultInstanceType",
        "instance_interruption_behavior": "instanceInterruptionBehavior",
        "instance_role": "instanceRole",
        "map_role": "mapRole",
        "target_capacity": "targetCapacity",
        "terminate_instances_with_expiration": "terminateInstancesWithExpiration",
        "valid_from": "validFrom",
        "valid_until": "validUntil",
        "vpc_subnet": "vpcSubnet",
        "eip_allocation_id": "eipAllocationId",
        "launch_template": "launchTemplate",
    },
)
class SpotFleetProps(BaseSpotFleetProps):
    def __init__(
        self,
        *,
        physical_name: typing.Optional[str] = None,
        block_duration: typing.Optional["BlockDuration"] = None,
        bootstrap_enabled: typing.Optional[bool] = None,
        custom_ami_id: typing.Optional[str] = None,
        default_instance_type: typing.Optional[aws_cdk.aws_ec2.InstanceType] = None,
        instance_interruption_behavior: typing.Optional[
            "InstanceInterruptionBehavior"
        ] = None,
        instance_role: typing.Optional[aws_cdk.aws_iam.Role] = None,
        map_role: typing.Optional[bool] = None,
        target_capacity: typing.Optional[jsii.Number] = None,
        terminate_instances_with_expiration: typing.Optional[bool] = None,
        valid_from: typing.Optional[str] = None,
        valid_until: typing.Optional[str] = None,
        vpc_subnet: typing.Optional[aws_cdk.aws_ec2.SubnetSelection] = None,
        eip_allocation_id: typing.Optional[str] = None,
        launch_template: typing.Optional["ILaunchtemplate"] = None,
    ) -> None:
        """
        :param physical_name: The value passed in by users to the physical name prop of the resource. - ``undefined`` implies that a physical name will be allocated by CloudFormation during deployment. - a concrete value implies a specific physical name - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation. Default: - The physical name will be allocated by CloudFormation at deployment time
        :param block_duration: 
        :param bootstrap_enabled: 
        :param custom_ami_id: 
        :param default_instance_type: 
        :param instance_interruption_behavior: 
        :param instance_role: 
        :param map_role: 
        :param target_capacity: 
        :param terminate_instances_with_expiration: 
        :param valid_from: 
        :param valid_until: 
        :param vpc_subnet: 
        :param eip_allocation_id: 
        :param launch_template: 

        stability
        :stability: experimental
        """
        if isinstance(vpc_subnet, dict):
            vpc_subnet = aws_cdk.aws_ec2.SubnetSelection(**vpc_subnet)
        self._values = {}
        if physical_name is not None:
            self._values["physical_name"] = physical_name
        if block_duration is not None:
            self._values["block_duration"] = block_duration
        if bootstrap_enabled is not None:
            self._values["bootstrap_enabled"] = bootstrap_enabled
        if custom_ami_id is not None:
            self._values["custom_ami_id"] = custom_ami_id
        if default_instance_type is not None:
            self._values["default_instance_type"] = default_instance_type
        if instance_interruption_behavior is not None:
            self._values[
                "instance_interruption_behavior"
            ] = instance_interruption_behavior
        if instance_role is not None:
            self._values["instance_role"] = instance_role
        if map_role is not None:
            self._values["map_role"] = map_role
        if target_capacity is not None:
            self._values["target_capacity"] = target_capacity
        if terminate_instances_with_expiration is not None:
            self._values[
                "terminate_instances_with_expiration"
            ] = terminate_instances_with_expiration
        if valid_from is not None:
            self._values["valid_from"] = valid_from
        if valid_until is not None:
            self._values["valid_until"] = valid_until
        if vpc_subnet is not None:
            self._values["vpc_subnet"] = vpc_subnet
        if eip_allocation_id is not None:
            self._values["eip_allocation_id"] = eip_allocation_id
        if launch_template is not None:
            self._values["launch_template"] = launch_template

    @builtins.property
    def physical_name(self) -> typing.Optional[str]:
        """The value passed in by users to the physical name prop of the resource.

        - ``undefined`` implies that a physical name will be allocated by
          CloudFormation during deployment.
        - a concrete value implies a specific physical name
        - ``PhysicalName.GENERATE_IF_NEEDED`` is a marker that indicates that a physical will only be generated
          by the CDK if it is needed for cross-environment references. Otherwise, it will be allocated by CloudFormation.

        default
        :default: - The physical name will be allocated by CloudFormation at deployment time
        """
        return self._values.get("physical_name")

    @builtins.property
    def block_duration(self) -> typing.Optional["BlockDuration"]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("block_duration")

    @builtins.property
    def bootstrap_enabled(self) -> typing.Optional[bool]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("bootstrap_enabled")

    @builtins.property
    def custom_ami_id(self) -> typing.Optional[str]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("custom_ami_id")

    @builtins.property
    def default_instance_type(self) -> typing.Optional[aws_cdk.aws_ec2.InstanceType]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("default_instance_type")

    @builtins.property
    def instance_interruption_behavior(
        self,
    ) -> typing.Optional["InstanceInterruptionBehavior"]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("instance_interruption_behavior")

    @builtins.property
    def instance_role(self) -> typing.Optional[aws_cdk.aws_iam.Role]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("instance_role")

    @builtins.property
    def map_role(self) -> typing.Optional[bool]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("map_role")

    @builtins.property
    def target_capacity(self) -> typing.Optional[jsii.Number]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("target_capacity")

    @builtins.property
    def terminate_instances_with_expiration(self) -> typing.Optional[bool]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("terminate_instances_with_expiration")

    @builtins.property
    def valid_from(self) -> typing.Optional[str]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("valid_from")

    @builtins.property
    def valid_until(self) -> typing.Optional[str]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("valid_until")

    @builtins.property
    def vpc_subnet(self) -> typing.Optional[aws_cdk.aws_ec2.SubnetSelection]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("vpc_subnet")

    @builtins.property
    def eip_allocation_id(self) -> typing.Optional[str]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("eip_allocation_id")

    @builtins.property
    def launch_template(self) -> typing.Optional["ILaunchtemplate"]:
        """
        stability
        :stability: experimental
        """
        return self._values.get("launch_template")

    def __eq__(self, rhs) -> bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs) -> bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SpotFleetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpcProvider(
    aws_cdk.core.Stack, metaclass=jsii.JSIIMeta, jsii_type="cdk-spot-one.VpcProvider"
):
    """
    stability
    :stability: experimental
    """

    def __init__(
        self,
        scope: typing.Optional[aws_cdk.core.Construct] = None,
        id: typing.Optional[str] = None,
        *,
        description: typing.Optional[str] = None,
        env: typing.Optional[aws_cdk.core.Environment] = None,
        stack_name: typing.Optional[str] = None,
        synthesizer: typing.Optional[aws_cdk.core.IStackSynthesizer] = None,
        tags: typing.Optional[typing.Mapping[str, str]] = None,
        termination_protection: typing.Optional[bool] = None,
    ) -> None:
        """Creates a new stack.

        :param scope: Parent of this stack, usually a Program instance.
        :param id: The construct ID of this stack. If ``stackName`` is not explicitly defined, this id (and any parent IDs) will be used to determine the physical ID of the stack.
        :param description: A description of the stack. Default: - No description.
        :param env: The AWS environment (account/region) where this stack will be deployed. Set the ``region``/``account`` fields of ``env`` to either a concrete value to select the indicated environment (recommended for production stacks), or to the values of environment variables ``CDK_DEFAULT_REGION``/``CDK_DEFAULT_ACCOUNT`` to let the target environment depend on the AWS credentials/configuration that the CDK CLI is executed under (recommended for development stacks). If the ``Stack`` is instantiated inside a ``Stage``, any undefined ``region``/``account`` fields from ``env`` will default to the same field on the encompassing ``Stage``, if configured there. If either ``region`` or ``account`` are not set nor inherited from ``Stage``, the Stack will be considered "*environment-agnostic*"". Environment-agnostic stacks can be deployed to any environment but may not be able to take advantage of all features of the CDK. For example, they will not be able to use environmental context lookups such as ``ec2.Vpc.fromLookup`` and will not automatically translate Service Principals to the right format based on the environment's AWS partition, and other such enhancements. Default: - The environment of the containing ``Stage`` if available, otherwise create the stack will be environment-agnostic.
        :param stack_name: Name to deploy the stack with. Default: - Derived from construct path.
        :param synthesizer: Synthesis method to use while deploying this stack. Default: - ``DefaultStackSynthesizer`` if the ``@aws-cdk/core:newStyleStackSynthesis`` feature flag is set, ``LegacyStackSynthesizer`` otherwise.
        :param tags: Stack tags that will be applied to all the taggable resources and the stack itself. Default: {}
        :param termination_protection: Whether to enable termination protection for this stack. Default: false
        """
        props = aws_cdk.core.StackProps(
            description=description,
            env=env,
            stack_name=stack_name,
            synthesizer=synthesizer,
            tags=tags,
            termination_protection=termination_protection,
        )

        jsii.create(VpcProvider, self, [scope, id, props])

    @jsii.member(jsii_name="getOrCreate")
    @builtins.classmethod
    def get_or_create(cls, scope: aws_cdk.core.Construct) -> aws_cdk.aws_ec2.IVpc:
        """
        :param scope: -

        stability
        :stability: experimental
        """
        return jsii.sinvoke(cls, "getOrCreate", [scope])


__all__ = [
    "BaseSpotFleetProps",
    "BlockDuration",
    "ILaunchtemplate",
    "InstanceInterruptionBehavior",
    "LaunchTemplate",
    "SpotFleet",
    "SpotFleetLaunchTemplateConfig",
    "SpotFleetProps",
    "VpcProvider",
]

publication.publish()
