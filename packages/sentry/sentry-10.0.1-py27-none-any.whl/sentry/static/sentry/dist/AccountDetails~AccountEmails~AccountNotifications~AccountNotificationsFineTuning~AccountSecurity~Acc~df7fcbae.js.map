{"version":3,"sources":["webpack:///./app/views/settings/components/forms/form.tsx","webpack:///./app/views/settings/components/forms/model.tsx","webpack:///./app/views/settings/components/forms/textField.jsx","webpack:///./app/components/switch.tsx","webpack:///./app/views/settings/components/forms/booleanField.jsx"],"names":["props","context","model","onSubmit","e","preventDefault","isSaving","getData","onSubmitSuccess","onSubmitError","saveForm","data","submitSuccess","error","submitError","saveOnBlur","apiEndpoint","apiMethod","resetOnError","onFieldChange","initialData","allowUndo","setInitialData","setFormOptions","getChildContext","this","form","componentWillUnmount","reset","render","className","children","footerClass","footerStyle","submitDisabled","submitLabel","submitPriority","cancelLabel","onCancel","extraButton","requireChanges","hideFooter","shouldShowFooter","StyledFooter","style","DefaultButtons","type","disabled","onClick","marginLeft","priority","isError","formChanged","propTypes","string","func","bool","object","element","childContextTypes","isRequired","defaultProps","Component","p","fields","map","errors","Map","fieldState","fieldDescriptor","snapshots","options","api","clear","resetForm","toJSON","formState","SAVING","size","replace","entries","setFieldDescriptor","id","set","defaultValue","setValue","removeField","createSnapshot","snapshot","unshift","getDescriptor","key","descriptor","has","get","getFieldState","getValue","getTransformedValue","transformer","value","getTransformedData","Object","keys","reduce","acc","getError","isValidRequiredField","isValidField","length","doApiRequest","endpoint","method","Promise","resolve","reject","request","success","response","Error","finalValue","transformInput","validateField","updateShowSaveState","updateShowReturnButtonState","validate","fieldIsRequiredMessage","push","forEach","field","errorMessage","setError","isValueChanged","saveOnBlurFieldOverride","setFieldState","undo","shift","validateForm","saveSnapshot","setFormSaving","then","resp","saveField","currentValue","oldValue","savePromise","saveFieldRequest","newValue","change","old","new","initialValue","setSaving","a","responseJSON","Array","isArray","non_field_errors","console","handleBlurField","handleSaveField","handleCancelSaveField","state","READY","ERROR","from","handleErrorResponse","err","formErrors","mapFormErrors","TextField","React","Switch","isActive","isLoading","isDisabled","toggle","SwitchButton","undefined","role","Toggle","getSize","getToggleSize","getToggleTop","getTranslateX","theme","borderDark","green","BooleanField","handleChange","onChange","onBlur","coerceValue","confirm","fieldProps","bind","switchProps","renderMessage","onConfirm","open","InputField","PropTypes","shape","true","node","false"],"mappings":"gMAmEA,kBA6CE,WAAYA,EAAcC,GAA1B,MACE,YAAMD,EAAOC,IAAQ,KAqCvB,EAAAC,MAAmB,EAAKF,MAAME,OAAS,IAAI,IAE3C,EAAAC,SAAW,SAAAC,GACTA,EAAEC,iBACE,EAAKH,MAAMI,WAIX,EAAKN,MAAMG,SACb,EAAKH,MAAMG,SACT,EAAKD,MAAMK,UACX,EAAKC,gBACL,EAAKC,cACLL,EACA,EAAKF,OAGP,EAAKA,MAAMQ,aAIf,EAAAF,gBAAkB,SAAAG,GACT,IAAAH,EAAA,QAAAA,gBACP,EAAKN,MAAMU,cAAcD,GAErBH,GACFA,EAAgBG,EAAM,EAAKT,QAI/B,EAAAO,cAAgB,SAAAI,GACP,IAAAJ,EAAA,QAAAA,cACP,EAAKP,MAAMY,YAAYD,GAEnBJ,GACFA,EAAcI,EAAO,EAAKX,QAtE1B,IAAAa,EAAA,EAAAA,WACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,UACAC,EAAA,EAAAA,aACAV,EAAA,EAAAA,gBACAC,EAAA,EAAAA,cACAU,EAAA,EAAAA,cACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,U,OAGF,EAAKnB,MAAMoB,eAAeF,GAC1B,EAAKlB,MAAMqB,eAAe,CACxBL,aAAY,EACZG,UAAS,EACTF,cAAa,EACbX,gBAAe,EACfC,cAAa,EACbM,WAAU,EACVC,YAAW,EACXC,UAAS,I,EA+Hf,OAnMkC,iBAwEhC,YAAAO,gBAAA,WACE,MAAO,CACLT,WAAYU,KAAKzB,MAAMe,WACvBW,KAAMD,KAAKvB,QAIf,YAAAyB,qBAAA,WACEF,KAAKvB,MAAM0B,SA0Cb,YAAAC,OAAA,sBACQ,aACJC,EAAA,EAAAA,UACAC,EAAA,EAAAA,SACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,eACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,eACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,SACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,eACAzB,EAAA,EAAAA,WACA0B,EAAA,EAAAA,WAEIC,OACkB,IAAfD,GAA8BA,GAAc1B,EAErD,OACE,0BACEZ,SAAUsB,KAAKtB,SACf2B,UAAWA,EAAS,eACNL,KAAKzB,MAAM,iBAEzB,6BA7LiB,mBA6LE+B,EAAYA,EAAS,CAAC7B,MAAOuB,KAAKvB,QAAU6B,GAE9DW,GACC,kBAACC,EAAY,CACXb,UAAWE,EACXY,MAAOX,EACPlB,WAAYA,GAEXwB,EACD,kBAACM,EAAc,KACZP,GACC,kBAAC,IAAQ,MACN,WAAM,OACL,kBAAC,IAAM,CACLQ,KAAK,SACLC,SAAU,EAAK7C,MAAMI,SACrB0C,QAASV,EACTM,MAAO,CAACK,WAAY,IALjB,MAaX,kBAAC,IAAQ,MACN,WAAM,OACL,kBAAC,IAAM,gBACQ,cACbC,SAAUd,EACVW,SACE,EAAK7C,MAAMiD,SACX,EAAKjD,MAAMI,UACX4B,KACCM,IAAkB,EAAKtC,MAAMkD,YAEhCN,KAAK,UAVF,UA5Kd,EAAAO,UAAiB,CACtBhB,YAAa,IAAUiB,OACvBhB,SAAU,IAAUiB,KACpBpD,SAAU,IAAUoD,KACpB/C,gBAAiB,IAAU+C,KAC3B9C,cAAe,IAAU8C,KACzBpC,cAAe,IAAUoC,KACzBrB,eAAgB,IAAUsB,KAC1BrB,YAAa,IAAUmB,OACvBlB,eAAgB,IAAUkB,OAC1BtB,YAAa,IAAUsB,OACvBrB,YAAa,IAAUwB,OACvBlB,YAAa,IAAUmB,QACvBtC,YAAa,IAAUqC,OAEvBjB,eAAgB,IAAUgB,KAE1BtC,aAAc,IAAUsC,KACxBf,WAAY,IAAUe,KACtBnC,UAAW,IAAUmC,KAErBzC,WAAY,IAAUyC,KACtBtD,MAAO,IAAUuD,OACjBxC,UAAW,IAAUqC,OACrBtC,YAAa,IAAUsC,OACvB,eAAgB,IAAUA,QAGrB,EAAAK,kBAAoB,CACzB5C,WAAY,IAAUyC,KAAKI,WAC3BlC,KAAM,IAAU+B,OAAOG,YAGlB,EAAAC,aAAe,CACpBxB,YAAa,YAAE,UACfF,YAAa,YAAE,gBACfD,gBAAgB,EAChBE,eAAgB,UAChBN,UAAW,eACXU,gBAAgB,EAChBnB,WAAW,EACXN,YAAY,GAyJhB,EAnMA,CAAkC,IAAM+C,WAAnB,MAqMrB,I,IAAMnB,EAAe,YAAO,MAAV,qBAAG,CAAa,8MAAwB,mLA0BvD,UAjBC,SAAAoB,GACA,OAACA,EAAEhD,YACH,OACA,IAAK,4SAiBH8B,EAAiB,YAAO,MAAV,qBAAG,CAAa,sKAEd,8EAAR,YAAM,K,8GCvQpB,aAiDE,WAAY,sBAAC,IAAAzB,EAAA,EAAAA,YAAa,iCA7C1B,KAAA4C,OAA4C,IAAWC,MAO3C,KAAAC,OAAS,IAAIC,IAQb,KAAAC,WAAa,IAAID,IAW7B,KAAAE,gBAAkB,IAAIF,IAKtB,KAAAG,UAA6B,GAM7B,KAAAlD,YAAc,GASZK,KAAK8C,QAAUA,GAAW,GACtBnD,GACFK,KAAKH,eAAeF,GAGtBK,KAAK+C,IAAM,IAAI,IAinBnB,OA3mBE,YAAA5C,MAAA,WACEH,KAAK+C,KAAO/C,KAAK+C,IAAIC,QACrBhD,KAAK+C,IAAM,KACX/C,KAAK4C,gBAAgBI,QACrBhD,KAAKiD,aAGP,YAAAA,UAAA,WACEjD,KAAKuC,OAAOS,QACZhD,KAAKyC,OAAOO,QACZhD,KAAK2C,WAAWK,QAChBhD,KAAK6C,UAAY,GACjB7C,KAAKL,YAAc,IAOrB,sBAAI,0BAAW,C,IAAf,WACE,OAAQ,IAAQK,KAAKL,YAAaK,KAAKuC,OAAOW,W,gCAIhD,sBAAI,uBAAQ,C,IAAZ,WACE,OAAOlD,KAAKuC,Q,gCAKd,sBAAI,uBAAQ,C,IAAZ,WACE,OAAOvC,KAAKmD,YAAc,IAAUC,Q,gCAKtC,sBAAI,sBAAO,C,IAAX,WACE,QAASpD,KAAKyC,OAAOY,M,gCAQvB,YAAAxD,eAAA,SAAeF,GACbK,KAAKuC,OAAOe,QAAQ3D,GAAe,IACnCK,KAAKL,YAAcK,KAAKuC,OAAOW,UAAY,GAE3ClD,KAAK6C,UAAY,CAAC,IAAIH,IAAI1C,KAAKuC,OAAOgB,aAMxC,YAAAzD,eAAA,SAAegD,GACb9C,KAAK8C,QAAUA,GAAW,IAM5B,YAAAU,mBAAA,SAAmBC,EAAYlF,GAE7ByB,KAAK4C,gBAAgBc,IAAID,EAAIlF,QAMG,IAAvBA,EAAMoF,mBACmB,IAAzB3D,KAAKL,YAAY8D,KAExBzD,KAAKL,YAAY8D,GACe,mBAAvBlF,EAAMoF,aACTpF,EAAMoF,eACNpF,EAAMoF,aAEZ3D,KAAKuC,OAAOmB,IAAID,EAAIzD,KAAKL,YAAY8D,KAGT,mBAAnBlF,EAAMqF,WACf5D,KAAKL,YAAY8D,GAAMlF,EAAMqF,SAAS5D,KAAKL,YAAY8D,GAAKlF,GAC5DyB,KAAKuC,OAAOmB,IAAID,EAAIzD,KAAKL,YAAY8D,MAOzC,YAAAI,YAAA,SAAYJ,GACVzD,KAAK4C,gBAAL,OAA4Ba,GAC5BzD,KAAKyC,OAAL,OAAmBgB,IAOrB,YAAAK,eAAA,sBACQC,EAAW,IAAIrB,IAAI1C,KAAKuC,OAAOgB,WACrC,OAAO,WAAM,SAAKV,UAAUmB,QAAf,KAGf,YAAAC,cAAA,SAAcR,EAAYS,GAExB,IAAMC,EAAanE,KAAK4C,gBAAgBwB,IAAIX,IAAOzD,KAAK4C,gBAAgByB,IAAIZ,GAC5E,OAAKU,EAIEA,EAAWD,GAHT,MAMX,YAAAI,cAAA,SAAcb,EAAYS,GAExB,IAAMvB,EAAa3C,KAAK2C,WAAWyB,IAAIX,IAAOzD,KAAK2C,WAAW0B,IAAIZ,GAClE,OAAKd,EAIEA,EAAWuB,GAHT,MAMX,YAAAK,SAAA,SAASd,GACP,OAAKzD,KAAKuC,OAAO6B,IAAIX,GAIdzD,KAAKuC,OAAO8B,IAAIZ,GAHd,IAMX,YAAAe,oBAAA,SAAoBf,GAClB,IAAMb,EAAkB5C,KAAK4C,gBAAgByB,IAAIZ,GAC3CgB,EACJ7B,GAAuD,mBAA7BA,EAAgB2B,SACtC3B,EAAgB2B,SAChB,KACAG,EAAQ1E,KAAKuE,SAASd,GAE5B,OAAOgB,EAAcA,EAAYC,GAASA,GAM5C,YAAA5F,QAAA,WACE,OAAOkB,KAAKuC,OAAOW,UAMrB,YAAAyB,mBAAA,sBACQ1E,EAAOD,KAAKlB,UAElB,OAAO8F,OAAOC,KAAK5E,GAChBuC,KAAI,SAAAiB,GAAM,OAACA,EAAI,EAAKe,oBAAV,OACVM,QAAO,SAACC,EAAK,G,IAAA,mBAACtB,EAAA,KAAIiB,EAAA,KAEjB,OADAK,EAAItB,GAAMiB,EACHK,IACN,KAGP,YAAAC,SAAA,SAASvB,GACP,OAAOzD,KAAKyC,OAAO2B,IAAIX,IAAOzD,KAAKyC,OAAO4B,IAAIZ,IAIhD,YAAAwB,qBAAA,SAAqBxB,GAEnB,IAAMtB,EAAanC,KAAKiE,cAAcR,EAAI,YACpCiB,EAAQ1E,KAAKuE,SAASd,GAC5B,OAAQtB,GAAyB,KAAVuC,GAAgB,YAAQA,IAGjD,YAAAQ,aAAA,SAAazB,GACX,OAA4C,KAApCzD,KAAKgF,SAASvB,IAAO,IAAI0B,QAGnC,YAAAC,aAAA,SAAa,GAAb,WACE7F,EAAA,EAAAA,YACAC,EAAA,EAAAA,UACAN,EAAA,EAAAA,KAMMmG,EAAW9F,GAAeS,KAAK8C,QAAQvD,aAAe,GACtD+F,EAAS9F,GAAaQ,KAAK8C,QAAQtD,UAEzC,OAAO,IAAI+F,SAAQ,SAACC,EAASC,GAE3B,OAAK,EAAK1C,IAGH,EAAKA,IAAI2C,QAAQL,EAAU,CAChCC,OAAM,EACNpG,KAAI,EACJyG,QAAS,SAAAC,GAAY,OAAAJ,EAAA,IACrBpG,MAAO,YAAS,OAAAqG,EAAA,MANTA,EAAO,IAAII,MAAM,oBAY9B,YAAAjC,SAAA,SAASH,EAAYiB,GACnB,IAAM9B,EAAkB5C,KAAK4C,gBAAgByB,IAAIZ,GAC7CqC,EAAapB,EAEb9B,GAA6D,mBAAnCA,EAAgBmD,iBAC5CD,EAAalD,EAAgBmD,eAAerB,IAG9C1E,KAAKuC,OAAOmB,IAAID,EAAIqC,GAEhB9F,KAAK8C,QAAQpD,eACfM,KAAK8C,QAAQpD,cAAc+D,EAAIqC,GAGjC9F,KAAKgG,cAAcvC,GACnBzD,KAAKiG,oBAAoBxC,EAAIqC,GAC7B9F,KAAKkG,4BAA4BzC,EAAIqC,IAIvC,YAAAE,cAAA,SAAcvC,GADd,WAEQ0C,EAAWnG,KAAKiE,cAAcR,EAAI,YACpChB,EAAgB,GAEI,mBAAb0D,IAET1D,EAAS0D,EAAS,CAAC1H,MAAOuB,KAAMyD,GAAE,EAAExD,KAAMD,KAAKlB,aAAe,IAGhE,IAAMsH,EAAyB,YAAE,qBAE5BpG,KAAKiF,qBAAqBxB,IAC7BhB,EAAO4D,KAAK,CAAC5C,EAAI2C,KAInB3D,EAA2B,IAAlBA,EAAO0C,OAAe,CAAC,CAAC1B,EAAI,OAAShB,GAEvC6D,SAAQ,SAAC,G,IAAA,mBAACC,EAAA,KAAOC,EAAA,KAAkB,SAAKC,SAASF,EAAOC,OAKjE,YAAAP,oBAAA,SAAoBxC,EAAYiB,GAC9B,IAAMgC,EAAiBhC,IAAU1E,KAAKL,YAAY8D,GAG5CkD,EAA0B3G,KAAKiE,cAAcR,EAAI,mBAChB,IAA5BkD,GAA2CA,GAGlD3G,KAAKsE,cAAcb,EAAI,cAAgBiD,GAI3C1G,KAAK4G,cAAcnD,EAAI,WAAYiD,IAIrC,YAAAR,4BAAA,SAA4BzC,EAAYiB,GACtC,IAAMgC,EAAiBhC,IAAU1E,KAAKL,YAAY8D,GACnBzD,KAAKiE,cAAcR,EAAI,qBAMlDzD,KAAKsE,cAAcb,EAAI,sBAAwBiD,GAInD1G,KAAK4G,cAAcnD,EAAI,mBAAoBiD,IAO7C,YAAAG,KAAA,WAEE,OAAI7G,KAAK6C,UAAUsC,OAAS,EACnB,MAGTnF,KAAK6C,UAAUiE,QACf9G,KAAKuC,OAAOe,QAAQtD,KAAK6C,UAAU,KAE5B,IAOT,YAAA5D,SAAA,WADA,WAEE,IAAKe,KAAK+G,eACR,OAAO,KAGT,IAAIC,EAA6BhH,KAAK8D,iBAEhC4B,EAAU1F,KAAKoF,aAAa,CAChClG,KAAMc,KAAK2E,uBA4Bb,OAzBA3E,KAAKiH,gBACLvB,EACGwB,MAAK,SAAAC,GAEAH,IACFA,IACAA,EAAe,MAGb,EAAKlE,QAAQ/D,iBACf,EAAK+D,QAAQ/D,gBAAgBoI,EAAM,MATzC,OAYS,SAAAA,GAELH,EAAe,KACX,EAAKlE,QAAQrD,cACf,EAAKI,eAAe,IAEtB,EAAKR,YAAY8H,GACb,EAAKrE,QAAQ9D,eACf,EAAK8D,QAAQ9D,cAAcmI,EAAM,MAIhCzB,GAST,YAAA0B,UAAA,SAAU3D,EAAY4D,GADtB,WAEQC,EAAWtH,KAAKL,YAAY8D,GAC5B8D,EAAcvH,KAAKwH,iBAAiB/D,EAAI4D,GAE9C,OAAKE,EAIEA,EACJL,MAAK,SAAAC,GACJ,IAAMM,EAAW,EAAKlD,SAASd,GACzBiE,EAAS,CAACC,IAAKL,EAAUM,IAAKH,GAWpC,YARsC,IAA3B,EAAK3E,QAAQlD,WAA6B,EAAKkD,QAAQlD,YAChE,YAAsB8H,EAAQ,EAAMjE,GAGlC,EAAKX,QAAQ/D,iBACf,EAAK+D,QAAQ/D,gBAAgBoI,EAAM,EAAM1D,EAAIiE,GAGxCP,KAdJ,OAgBE,SAAA/H,GAIL,OAHI,EAAK0D,QAAQ9D,eACf,EAAK8D,QAAQ9D,cAAcI,EAAO,EAAMqE,GAEnC,MAvBF,MAqCX,YAAA+D,iBAAA,SAAiB/D,EAAY4D,G,MAD7B,OAEQQ,EAAe7H,KAAKL,YAAY8D,GAItC,GACE4D,IAAiBQ,GACC,KAAjBR,IAAwB,YAAQQ,GAEjC,OAAO,KAKT,GADA7H,KAAKgG,cAAcvC,IACdzD,KAAKkF,aAAazB,GACrB,OAAO,KAIT,IAAIuD,EAA6BhH,KAAK8D,iBAGtC9D,KAAK8H,UAAUrE,GAAI,GAEnB,IAAMb,EAAkB5C,KAAK4C,gBAAgByB,IAAIZ,GAG3C3E,EAC+B,mBAA5B8D,EAAgB9D,QAAyB8D,EAAgB9D,QAAU,SAAAiJ,GAAK,OAAAA,GAE3ErC,EAAU1F,KAAKoF,aAAa,CAChClG,KAAMJ,GAAO,KACV,EAAC2E,GAAKzD,KAAKwE,oBAAoBf,GAAG,GACnC,CAAChF,MAAOuB,KAAMyD,GAAE,EAAExD,KAAMD,KAAKlB,cAyDjC,OArDA4G,EACGwB,MAAK,SAAAhI,GAYJ,OAXA,EAAK4I,UAAUrE,GAAI,GAGfuD,IACFA,IACAA,EAAe,MAIjB,EAAKrH,YAAY8D,GAAM,EAAKc,SAASd,GAE9BvE,KAbX,OAeS,SAAAiI,GAELH,EAAe,KAIK,EAAK/C,cAAcR,EAAI,iBAEzC,EAAKG,SAASH,EAAIoE,GAMhBV,GAAQA,EAAKa,aAEXC,MAAMC,QAAQf,EAAKa,aAAavE,KAAQ0D,EAAKa,aAAavE,GAAI0B,OAEhE,EAAKsB,SAAShD,EAAI0D,EAAKa,aAAavE,GAAI,IAExCwE,MAAMC,QAAQf,EAAKa,aAAaG,mBAChChB,EAAKa,aAAaG,iBAAiBhD,QAEnC,YAAgBgC,EAAKa,aAAaG,iBAAiB,GAAI,KAEvD,EAAK1B,SAAShD,EAAI,KAElB,EAAKgD,SAAShD,EAAI,kBAIpB,EAAKgD,SAAShD,EAAI,kBAIpB2E,QAAQhJ,MAAM,0BAA2B+H,GAAQA,EAAKa,iBAGnDtC,GAST,YAAA2C,gBAAA,SAAgB5E,EAAY4D,GAE1B,IAAKrH,KAAK8C,QAAQxD,WAChB,OAAO,KAIT,IAAMqH,EAA0B3G,KAAKiE,cAAcR,EAAI,cACvD,YAAuC,IAA5BkD,GAA4CA,EAIhD3G,KAAKoH,UAAU3D,EAAI4D,GAHjB,MAOX,YAAAJ,cAAA,WACEjH,KAAKmD,UAAY,IAAUC,QAO7B,YAAAkF,gBAAA,SAAgB7E,EAAY4D,GAD5B,WAEQE,EAAcvH,KAAKoH,UAAU3D,EAAI4D,GAEvC,OAAKE,EAIEA,EAAYL,MAAK,WACtB,EAAKN,cAAcnD,EAAI,YAAY,MAJ5B,MAYX,YAAA8E,sBAAA,SAAsB9E,GACpBzD,KAAK4D,SAASH,EAAIzD,KAAKL,YAAY8D,IACnCzD,KAAK4G,cAAcnD,EAAI,YAAY,IAIrC,YAAAmD,cAAA,SAAcnD,EAAYS,EAAaQ,G,MAC/B8D,EAAQ,OAAH,IAAG,CAAH,eACLxI,KAAK2C,WAAW0B,IAAIZ,IAAO,MAAG,MACjCS,GAAMQ,EAAK,IAEd1E,KAAK2C,WAAWe,IAAID,EAAI+E,IAO1B,YAAAV,UAAA,SAAUrE,EAAYiB,GAEpB1E,KAAKyG,SAAShD,GAAI,GAClBzD,KAAK4G,cAAcnD,EAAI,IAAUL,OAAQsB,GACzC1E,KAAK4G,cAAcnD,EAAI,IAAUgF,OAAQ/D,IAO3C,YAAA+B,SAAA,SAAShD,EAAYrE,GAGbA,GACJY,KAAKmD,UAAY,IAAUuF,MAC3B1I,KAAKyC,OAAOiB,IAAID,EAAIrE,KAEpBY,KAAKmD,UAAY,IAAUsF,MAC3BzI,KAAKyC,OAAL,OAAmBgB,IAIrBzD,KAAK4G,cAAcnD,EAAI,IAAUL,QAAQ,IAO3C,YAAA2D,aAAA,WADA,WAIE,OAFAkB,MAAMU,KAAK3I,KAAK4C,gBAAgBiC,QAAQyB,SAAQ,SAAA7C,GAAM,OAAC,EAAKuC,cAAN,OAE9ChG,KAAK0B,SAIf,YAAAkH,oBAAA,SAAoB,GADpB,WACqBzB,QAAA,YAAAa,aACdb,GAKLvC,OAAOC,KAAKsC,GAAMb,SAAQ,SAAA7C,GAEf,qBAAPA,GACAwE,MAAMC,QAAQf,EAAKgB,mBACnBhB,EAAKgB,iBAAiBhD,OAEtB,YAAgBgC,EAAKgB,iBAAiB,GAAI,KACjCF,MAAMC,QAAQf,EAAK1D,KAAQ0D,EAAK1D,GAAI0B,QAE7C,EAAKsB,SAAShD,EAAI0D,EAAK1D,GAAI,QAMjC,YAAAtE,cAAA,SAAcD,GAEZc,KAAKmD,UAAY,IAAUsF,MAC3BzI,KAAKL,YAAcT,GAIrB,YAAAG,YAAA,SAAYwJ,GACV7I,KAAKmD,UAAY,IAAUuF,MAC3B1I,KAAK8I,WAAa9I,KAAK+I,cAAcF,EAAIb,cACzChI,KAAK4I,oBAAoB,CAACZ,aAAchI,KAAK8I,cAG/C,YAAAC,cAAA,SAAcf,GACZ,OAAOA,GA3pBG,aAAX,K,6BAQW,aAAX,K,iCAKW,aAAX,K,gCAwDD,aADC,K,0BAGA,MAGD,aADC,K,uBAGA,MAID,aADC,K,uBAGA,MAID,aADC,K,sBAGA,MAyKD,aADC,K,uBAkBA,MAGD,aADC,K,4BAqBA,MAGD,aADC,K,kCAcA,MAGD,aADC,K,0CAcA,MAMD,aADC,K,mBAWA,MAMD,aADC,K,uBAsCA,MAQD,aADC,K,wBA+BA,MAYD,aADC,K,+BA4FA,MAQD,aADC,K,8BAcA,MAGD,aADC,K,4BAGA,MAMD,aADC,K,8BAWA,MAMD,aADC,K,oCAIA,MAGD,aADC,K,4BAOA,MAMD,aADC,K,wBAMA,MAMD,aADC,K,uBAcA,MAMD,aADC,K,2BAKA,MAGD,aADC,K,kCAmBA,MAGD,aADC,K,4BAKA,MAGD,aADC,K,0BAKA,MAKH,EAxqBA,GA0qBe,O,mMCvsBMgB,E,yIAMjB,OAAO,kBAAC,IAAD,OAAgBhJ,KAAKzB,MAArB,CAA4B8C,KAAK,c,GANL4H,IAAM5G,WAAxB2G,E,6FCWfE,EAA0B,SAAC,G,IAC/B7F,EAAA,EAAAA,KACA8F,EAAA,EAAAA,SACAC,EAAA,EAAAA,UACAC,EAAA,EAAAA,WACAC,EAAA,EAAAA,OACA7F,EAAA,EAAAA,GACApD,EAAA,EAAAA,UACI,OACJ,kBAACkJ,EAAY,CACX9F,GAAIA,EACJpC,KAAK,SACLhB,UAAWA,EACXkB,QAAS8H,OAAaG,EAAYF,EAClCG,KAAK,WAAU,eACDN,EACdC,UAAWA,EACXC,WAAYA,EACZF,SAAUA,EACV9F,KAAMA,EAAI,eACG,UAEb,kBAACqG,EAAM,CAACL,WAAYA,EAAYF,SAAUA,EAAU9F,KAAMA,MAa9D6F,EAAO9G,aAAe,CACpBiB,KAAM,MAKR,I,IAAMsG,EAAU,SAACrH,GAAkB,MAAY,OAAXA,EAAEe,KAAgB,GAAnB,IAC7BuG,EAAgB,SAACtH,GAAkB,OAAAqH,EAAQrH,IAAiB,OAAXA,EAAEe,KAAgB,EAAhC,KACnCwG,EAAe,SAACvH,GAAkB,MAAY,OAAXA,EAAEe,KAAgB,EAAnB,GAClCyG,EAAgB,SAACxH,GACrB,OAAAA,EAAE6G,SAAWU,EAAavH,GAAKqH,EAAQrH,GAAKuH,EAAavH,IAErDiH,EAAe,YAAO,SAAV,oBAAG,CAAgB,ggBAAY,uFAIiC,6HAIR,wBACJ,gBACnD,iBACW,yBACJ,yEAKiB,gIAbrB,SAAAjH,GAAK,OAACA,EAAE6G,SAAW7G,EAAEyH,MAAMC,WAAa1H,EAAEyH,MAArC,eAIf,SAAAzH,GAAK,OAACA,EAAE8G,WAAa9G,EAAE+G,WAAa,cAA/B,aACG,SAAA/G,GAAK,OAACA,EAAE8G,WAAa9G,EAAE+G,WAAa,OAA/B,OACbM,GACD,SAAArH,GAAK,SAAAqH,EAAQrH,KACLqH,GAKC,SAAArH,GAAK,OAAAA,EAAEyH,MAAF,cAUnBL,EAAS,YAAO,OAAV,oBAAG,CAAc,kPAAY,4GAKpB,gCACkB,kBACf,kBACC,sBACwC,iBACpB,SALpCG,EACiBC,EACfF,EACCA,GACI,SAAAtH,GAAK,OAACA,EAAE6G,SAAW7G,EAAEyH,MAAME,MAAQ3H,EAAEyH,MAAhC,SACR,SAAAzH,GAAK,OAACA,EAAE+G,WAAa,GAAhB,QAEH,O,6zBC7FMa,E,mLAYnBC,aAAe,SAACzF,EAAO0F,EAAUC,EAAQ1L,GAEvC,IAAM8I,EAAW,EAAK6C,aAAa5F,GACnC0F,EAAS3C,EAAU9I,GACnB0L,EAAO5C,EAAU9I,I,2DARP+F,GACV,QAAOA,I,+BAUA,aAC0B1E,KAAKzB,MAA/BgM,EADA,EACAA,QAAYC,EADZ,mBAGP,OACE,kBAAC,IAAD,OACMA,EADN,CAEE/K,cAAY,EACZ8G,MAAO,YAAmD,IAAjD6D,EAAiD,EAAjDA,SAAUC,EAAuC,EAAvCA,OAAQ3F,EAA+B,EAA/BA,MAAOpD,EAAwB,EAAxBA,SAAa/C,EAAW,gDAElD4L,EAAe,EAAKA,aAAaM,KAAK,EAAM/F,EAAO0F,EAAUC,GAE7DK,EAAc,EAAH,CACfrH,KAAM,MACH9E,EAFY,CAGf4K,WAAYzE,EACZ2E,WAAY/H,EACZgI,OAAQa,IAGV,OAAII,EAEA,kBAAC,IAAD,CACEI,cAAe,kBAAMJ,GAAS7F,IAC9BkG,UAAW,kBAAMT,EAAa,OAE7B,gBAAEU,EAAF,EAAEA,KAAF,OACC,kBAAC,IAAD,OACMH,EADN,CAEEpB,OAAQ,SAAA3K,GAGF4L,GAAS7F,GAEXmG,IAIFV,EAAaxL,UAQlB,kBAAC,IAAW+L,W,GAhEaI,KAArBZ,E,2BAAAA,EACZtI,U,KACFkJ,IAAWlJ,U,CACd2I,QAASQ,IAAUC,MAAM,CACvBC,KAAMF,IAAUG,KAChBC,MAAOJ,IAAUG","file":"AccountDetails~AccountEmails~AccountNotifications~AccountNotificationsFineTuning~AccountSecurity~Acc~df7fcbae.js","sourcesContent":["import {Observer} from 'mobx-react';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport styled from 'react-emotion';\n\nimport {APIRequestMethod} from 'app/api';\nimport {t} from 'app/locale';\nimport Button from 'app/components/button';\nimport FormModel, {\n  FormOptions,\n  FieldValue,\n} from 'app/views/settings/components/forms/model';\nimport Panel from 'app/components/panels/panel';\nimport space from 'app/styles/space';\n\ntype Data = {};\n\ntype RenderProps = {\n  model: FormModel;\n};\n\ntype RenderFunc = (props: RenderProps) => React.ReactNode;\n\n// Type guard for render func.\nfunction isRenderFunc(func: React.ReactNode | Function): func is RenderFunc {\n  return typeof func === 'function';\n}\n\ntype Props = {\n  apiMethod?: APIRequestMethod;\n  apiEndpoint?: string;\n  children: React.ReactNode | RenderFunc;\n  className?: string;\n  cancelLabel?: string;\n  submitDisabled?: boolean;\n  submitLabel?: string;\n  submitPriority?: Button['props']['priority'];\n  footerClass?: string;\n  footerStyle?: React.CSSProperties;\n  extraButton?: React.ReactNode;\n  initialData?: Data;\n  // Require changes before able to submit form\n  requireChanges?: boolean;\n  // Reset form when there are errors; after submit\n  resetOnError?: boolean;\n  hideFooter?: boolean;\n  allowUndo?: boolean;\n  // Save field on control blur\n  saveOnBlur?: boolean;\n  model?: FormModel;\n  'data-test-id'?: string;\n\n  onCancel?: (e: React.MouseEvent) => void;\n  onSubmit?: (\n    data: Data,\n    onSubmitSuccess: (data: Data) => void,\n    onSubmitError: (error: any) => void,\n    e: React.FormEvent,\n    model: FormModel\n  ) => void;\n} & Pick<FormOptions, 'onSubmitSuccess' | 'onSubmitError' | 'onFieldChange'>;\n\ntype Context = {\n  saveOnBlur: boolean;\n  form: FormModel;\n};\n\nexport default class Form extends React.Component<Props> {\n  static propTypes: any = {\n    cancelLabel: PropTypes.string,\n    onCancel: PropTypes.func,\n    onSubmit: PropTypes.func,\n    onSubmitSuccess: PropTypes.func,\n    onSubmitError: PropTypes.func,\n    onFieldChange: PropTypes.func,\n    submitDisabled: PropTypes.bool,\n    submitLabel: PropTypes.string,\n    submitPriority: PropTypes.string,\n    footerClass: PropTypes.string,\n    footerStyle: PropTypes.object,\n    extraButton: PropTypes.element,\n    initialData: PropTypes.object,\n    // Require changes before able to submit form\n    requireChanges: PropTypes.bool,\n    // Reset form when there are errors, after submit\n    resetOnError: PropTypes.bool,\n    hideFooter: PropTypes.bool,\n    allowUndo: PropTypes.bool,\n    // Save field on control blur\n    saveOnBlur: PropTypes.bool,\n    model: PropTypes.object,\n    apiMethod: PropTypes.string,\n    apiEndpoint: PropTypes.string,\n    'data-test-id': PropTypes.string,\n  };\n\n  static childContextTypes = {\n    saveOnBlur: PropTypes.bool.isRequired,\n    form: PropTypes.object.isRequired,\n  };\n\n  static defaultProps = {\n    cancelLabel: t('Cancel'),\n    submitLabel: t('Save Changes'),\n    submitDisabled: false,\n    submitPriority: 'primary' as 'primary',\n    className: 'form-stacked',\n    requireChanges: false,\n    allowUndo: false,\n    saveOnBlur: false,\n  };\n\n  constructor(props: Props, context: Context) {\n    super(props, context);\n    const {\n      saveOnBlur,\n      apiEndpoint,\n      apiMethod,\n      resetOnError,\n      onSubmitSuccess,\n      onSubmitError,\n      onFieldChange,\n      initialData,\n      allowUndo,\n    } = props;\n\n    this.model.setInitialData(initialData);\n    this.model.setFormOptions({\n      resetOnError,\n      allowUndo,\n      onFieldChange,\n      onSubmitSuccess,\n      onSubmitError,\n      saveOnBlur,\n      apiEndpoint,\n      apiMethod,\n    });\n  }\n\n  getChildContext() {\n    return {\n      saveOnBlur: this.props.saveOnBlur,\n      form: this.model,\n    };\n  }\n\n  componentWillUnmount() {\n    this.model.reset();\n  }\n\n  model: FormModel = this.props.model || new FormModel();\n\n  onSubmit = e => {\n    e.preventDefault();\n    if (this.model.isSaving) {\n      return;\n    }\n\n    if (this.props.onSubmit) {\n      this.props.onSubmit(\n        this.model.getData(),\n        this.onSubmitSuccess,\n        this.onSubmitError,\n        e,\n        this.model\n      );\n    } else {\n      this.model.saveForm();\n    }\n  };\n\n  onSubmitSuccess = data => {\n    const {onSubmitSuccess} = this.props;\n    this.model.submitSuccess(data);\n\n    if (onSubmitSuccess) {\n      onSubmitSuccess(data, this.model);\n    }\n  };\n\n  onSubmitError = error => {\n    const {onSubmitError} = this.props;\n    this.model.submitError(error);\n\n    if (onSubmitError) {\n      onSubmitError(error, this.model);\n    }\n  };\n\n  render() {\n    const {\n      className,\n      children,\n      footerClass,\n      footerStyle,\n      submitDisabled,\n      submitLabel,\n      submitPriority,\n      cancelLabel,\n      onCancel,\n      extraButton,\n      requireChanges,\n      saveOnBlur,\n      hideFooter,\n    } = this.props;\n    const shouldShowFooter =\n      typeof hideFooter !== 'undefined' ? !hideFooter : !saveOnBlur;\n\n    return (\n      <form\n        onSubmit={this.onSubmit}\n        className={className}\n        data-test-id={this.props['data-test-id']}\n      >\n        <div>{isRenderFunc(children) ? children({model: this.model}) : children}</div>\n\n        {shouldShowFooter && (\n          <StyledFooter\n            className={footerClass}\n            style={footerStyle}\n            saveOnBlur={saveOnBlur}\n          >\n            {extraButton}\n            <DefaultButtons>\n              {onCancel && (\n                <Observer>\n                  {() => (\n                    <Button\n                      type=\"button\"\n                      disabled={this.model.isSaving}\n                      onClick={onCancel}\n                      style={{marginLeft: 5}}\n                    >\n                      {cancelLabel}\n                    </Button>\n                  )}\n                </Observer>\n              )}\n\n              <Observer>\n                {() => (\n                  <Button\n                    data-test-id=\"form-submit\"\n                    priority={submitPriority}\n                    disabled={\n                      this.model.isError ||\n                      this.model.isSaving ||\n                      submitDisabled ||\n                      (requireChanges ? !this.model.formChanged : false)\n                    }\n                    type=\"submit\"\n                  >\n                    {submitLabel}\n                  </Button>\n                )}\n              </Observer>\n            </DefaultButtons>\n          </StyledFooter>\n        )}\n      </form>\n    );\n  }\n}\n\nconst StyledFooter = styled('div')<{saveOnBlur?: boolean}>`\n  display: flex;\n  justify-content: flex-end;\n  margin-top: 25px;\n  border-top: 1px solid #e9ebec;\n  background: none;\n  padding: 16px 0 0;\n  margin-bottom: 16px;\n\n  ${p =>\n    !p.saveOnBlur &&\n    `\n  ${Panel} & {\n    margin-top: 0;\n    padding-right: 36px;\n  }\n\n  /* Better padding with form inside of a modal */\n  .modal-content & {\n    padding-right: 30px;\n    margin-left: -30px;\n    margin-right: -30px;\n    margin-bottom: -30px;\n    margin-top: 16px;\n    padding-bottom: 16px;\n  }\n  `};\n`;\n\nconst DefaultButtons = styled('div')`\n  display: grid;\n  grid-gap: ${space(1)};\n  grid-auto-flow: column;\n  justify-content: flex-end;\n  flex: 1;\n`;\n\nexport {FieldValue};\n","import {observable, computed, action, ObservableMap} from 'mobx';\nimport isEqual from 'lodash/isEqual';\n\nimport {Client, APIRequestMethod} from 'app/api';\nimport {addErrorMessage, saveOnBlurUndoMessage} from 'app/actionCreators/indicator';\nimport {defined} from 'app/utils';\nimport {t} from 'app/locale';\nimport FormState from 'app/components/forms/state';\n\ntype Snapshot = Map<string, FieldValue>;\ntype SaveSnapshot = (() => number) | null;\n\nexport type FieldValue = string | number | boolean | undefined; //is undefined valid here?\n\nexport type FormOptions = {\n  apiEndpoint?: string;\n  apiMethod?: APIRequestMethod;\n  allowUndo?: boolean;\n  resetOnError?: boolean;\n  saveOnBlur?: boolean;\n  onFieldChange?: (id: string, finalValue: FieldValue) => void;\n  onSubmitSuccess?: (\n    response: any,\n    instance: FormModel,\n    id?: string,\n    change?: {old: FieldValue; new: FieldValue}\n  ) => void;\n  onSubmitError?: (error: any, instance: FormModel, id?: string) => void;\n};\n\ntype OptionsWithInitial = FormOptions & {initialData?: object};\n\nclass FormModel {\n  /**\n   * Map of field name -> value\n   */\n  fields: ObservableMap<string, FieldValue> = observable.map();\n\n  /**\n   * Errors for individual fields\n   * Note we don't keep error in `this.fieldState` so that we can easily\n   * See if the form is in an \"error\" state with the `isError` getter\n   */\n  @observable errors = new Map();\n\n  /**\n   * State of individual fields\n   *\n   * Map of field name -> object\n   */\n\n  @observable fieldState = new Map();\n\n  /**\n   * State of the form as a whole\n   */\n  @observable formState;\n\n  /**\n   * Holds field properties as declared in <Form>\n   * Does not need to be observable since these props should never change\n   */\n  fieldDescriptor = new Map();\n\n  /**\n   * Holds a list of `fields` states\n   */\n  snapshots: Array<Snapshot> = [];\n\n  /**\n   * POJO of field name -> value\n   * It holds field values \"since last save\"\n   */\n  initialData = {};\n\n  api: Client | null;\n\n  formErrors: any;\n\n  options: FormOptions;\n\n  constructor({initialData, ...options}: OptionsWithInitial = {}) {\n    this.options = options || {};\n    if (initialData) {\n      this.setInitialData(initialData);\n    }\n\n    this.api = new Client();\n  }\n\n  /**\n   * Reset state of model\n   */\n  reset() {\n    this.api && this.api.clear();\n    this.api = null;\n    this.fieldDescriptor.clear();\n    this.resetForm();\n  }\n\n  resetForm() {\n    this.fields.clear();\n    this.errors.clear();\n    this.fieldState.clear();\n    this.snapshots = [];\n    this.initialData = {};\n  }\n\n  /**\n   * Deep equality comparison between last saved state and current fields state\n   */\n  @computed\n  get formChanged() {\n    return !isEqual(this.initialData, this.fields.toJSON());\n  }\n\n  @computed\n  get formData() {\n    return this.fields;\n  }\n\n  /** Is form saving */\n  @computed\n  get isSaving() {\n    return this.formState === FormState.SAVING;\n  }\n\n  /** Does form have any errors */\n  @computed\n  get isError() {\n    return !!this.errors.size;\n  }\n\n  /**\n   * Sets initial form data\n   *\n   * Also resets snapshots\n   */\n  setInitialData(initialData?: object) {\n    this.fields.replace(initialData || {});\n    this.initialData = this.fields.toJSON() || {};\n\n    this.snapshots = [new Map(this.fields.entries())];\n  }\n\n  /**\n   * Set form options\n   */\n  setFormOptions(options: FormOptions) {\n    this.options = options || {};\n  }\n\n  /**\n   * Set field properties\n   */\n  setFieldDescriptor(id: string, props) {\n    //TODO(TS): add type to props\n    this.fieldDescriptor.set(id, props);\n\n    // Set default value iff initialData for field is undefined\n    // This must take place before checking for `props.setValue` so that it can\n    // be applied to `defaultValue`\n    if (\n      typeof props.defaultValue !== 'undefined' &&\n      typeof this.initialData[id] === 'undefined'\n    ) {\n      this.initialData[id] =\n        typeof props.defaultValue === 'function'\n          ? props.defaultValue()\n          : props.defaultValue;\n\n      this.fields.set(id, this.initialData[id]);\n    }\n\n    if (typeof props.setValue === 'function') {\n      this.initialData[id] = props.setValue(this.initialData[id], props);\n      this.fields.set(id, this.initialData[id]);\n    }\n  }\n\n  /**\n   * Remove a field from the descriptor map and errors.\n   */\n  removeField(id: string) {\n    this.fieldDescriptor.delete(id);\n    this.errors.delete(id);\n  }\n\n  /**\n   * Creates a cloned Map of `this.fields` and returns a closure that when called\n   * will save Map to `snapshots\n   */\n  createSnapshot() {\n    const snapshot = new Map(this.fields.entries());\n    return () => this.snapshots.unshift(snapshot);\n  }\n\n  getDescriptor(id: string, key: string) {\n    // Needs to call `has` or else component will not be reactive if `id` doesn't exist in observable map\n    const descriptor = this.fieldDescriptor.has(id) && this.fieldDescriptor.get(id);\n    if (!descriptor) {\n      return null;\n    }\n\n    return descriptor[key];\n  }\n\n  getFieldState(id: string, key: string) {\n    // Needs to call `has` or else component will not be reactive if `id` doesn't exist in observable map\n    const fieldState = this.fieldState.has(id) && this.fieldState.get(id);\n    if (!fieldState) {\n      return null;\n    }\n\n    return fieldState[key];\n  }\n\n  getValue(id: string) {\n    if (!this.fields.has(id)) {\n      return '';\n    }\n\n    return this.fields.get(id);\n  }\n\n  getTransformedValue(id: string) {\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n    const transformer =\n      fieldDescriptor && typeof fieldDescriptor.getValue === 'function'\n        ? fieldDescriptor.getValue\n        : null;\n    const value = this.getValue(id);\n\n    return transformer ? transformer(value) : value;\n  }\n\n  /**\n   * Data represented in UI\n   */\n  getData() {\n    return this.fields.toJSON();\n  }\n\n  /**\n   * Form data that will be sent to API endpoint (i.e. after transforms)\n   */\n  getTransformedData() {\n    const form = this.getData();\n\n    return Object.keys(form)\n      .map(id => [id, this.getTransformedValue(id)])\n      .reduce((acc, [id, value]) => {\n        acc[id] = value;\n        return acc;\n      }, {});\n  }\n\n  getError(id: string) {\n    return this.errors.has(id) && this.errors.get(id);\n  }\n\n  // Returns true if not required or is required and is not empty\n  isValidRequiredField(id: string) {\n    // Check field descriptor to see if field is required\n    const isRequired = this.getDescriptor(id, 'required');\n    const value = this.getValue(id);\n    return !isRequired || (value !== '' && defined(value));\n  }\n\n  isValidField(id: string) {\n    return (this.getError(id) || []).length === 0;\n  }\n\n  doApiRequest({\n    apiEndpoint,\n    apiMethod,\n    data,\n  }: {\n    apiEndpoint?: string;\n    apiMethod?: APIRequestMethod;\n    data: object;\n  }) {\n    const endpoint = apiEndpoint || this.options.apiEndpoint || '';\n    const method = apiMethod || this.options.apiMethod;\n\n    return new Promise((resolve, reject) => {\n      //should never happen but TS complains if we don't check\n      if (!this.api) {\n        return reject(new Error('Api not set'));\n      }\n      return this.api.request(endpoint, {\n        method,\n        data,\n        success: response => resolve(response),\n        error: error => reject(error),\n      });\n    });\n  }\n\n  @action\n  setValue(id: string, value: FieldValue) {\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n    let finalValue = value;\n\n    if (fieldDescriptor && typeof fieldDescriptor.transformInput === 'function') {\n      finalValue = fieldDescriptor.transformInput(value);\n    }\n\n    this.fields.set(id, finalValue);\n\n    if (this.options.onFieldChange) {\n      this.options.onFieldChange(id, finalValue);\n    }\n\n    this.validateField(id);\n    this.updateShowSaveState(id, finalValue);\n    this.updateShowReturnButtonState(id, finalValue);\n  }\n\n  @action\n  validateField(id: string) {\n    const validate = this.getDescriptor(id, 'validate');\n    let errors: any[] = [];\n\n    if (typeof validate === 'function') {\n      // Returns \"tuples\" of [id, error string]\n      errors = validate({model: this, id, form: this.getData()}) || [];\n    }\n\n    const fieldIsRequiredMessage = t('Field is required');\n\n    if (!this.isValidRequiredField(id)) {\n      errors.push([id, fieldIsRequiredMessage]);\n    }\n\n    // If we have no errors, ensure we clear the field\n    errors = errors.length === 0 ? [[id, null]] : errors;\n\n    errors.forEach(([field, errorMessage]) => this.setError(field, errorMessage));\n    return undefined;\n  }\n\n  @action\n  updateShowSaveState(id: string, value: FieldValue) {\n    const isValueChanged = value !== this.initialData[id];\n    // Update field state to \"show save\" if save on blur is disabled for this field\n    // (only if contents of field differs from initial value)\n    const saveOnBlurFieldOverride = this.getDescriptor(id, 'saveOnBlur');\n    if (typeof saveOnBlurFieldOverride === 'undefined' || saveOnBlurFieldOverride) {\n      return;\n    }\n    if (this.getFieldState(id, 'showSave') === isValueChanged) {\n      return;\n    }\n\n    this.setFieldState(id, 'showSave', isValueChanged);\n  }\n\n  @action\n  updateShowReturnButtonState(id: string, value: FieldValue) {\n    const isValueChanged = value !== this.initialData[id];\n    const shouldShowReturnButton = this.getDescriptor(id, 'showReturnButton');\n\n    if (!shouldShowReturnButton) {\n      return;\n    }\n    // Only update state if state has changed\n    if (this.getFieldState(id, 'showReturnButton') === isValueChanged) {\n      return;\n    }\n\n    this.setFieldState(id, 'showReturnButton', isValueChanged);\n  }\n\n  /**\n   * Changes form values to previous saved state\n   */\n  @action\n  undo() {\n    // Always have initial data snapshot\n    if (this.snapshots.length < 2) {\n      return null;\n    }\n\n    this.snapshots.shift();\n    this.fields.replace(this.snapshots[0]);\n\n    return true;\n  }\n\n  /**\n   * Attempts to save entire form to server and saves a snapshot for undos\n   */\n  @action\n  saveForm() {\n    if (!this.validateForm()) {\n      return null;\n    }\n\n    let saveSnapshot: SaveSnapshot = this.createSnapshot();\n\n    const request = this.doApiRequest({\n      data: this.getTransformedData(),\n    });\n\n    this.setFormSaving();\n    request\n      .then(resp => {\n        // save snapshot\n        if (saveSnapshot) {\n          saveSnapshot();\n          saveSnapshot = null;\n        }\n\n        if (this.options.onSubmitSuccess) {\n          this.options.onSubmitSuccess(resp, this);\n        }\n      })\n      .catch(resp => {\n        // should we revert field value to last known state?\n        saveSnapshot = null;\n        if (this.options.resetOnError) {\n          this.setInitialData({});\n        }\n        this.submitError(resp);\n        if (this.options.onSubmitError) {\n          this.options.onSubmitError(resp, this);\n        }\n      });\n\n    return request;\n  }\n\n  /**\n   * Attempts to save field and show undo message if necessary.\n   * Calls submit handlers.\n   * TODO(billy): This should return a promise that resolves (instead of null)\n   */\n  @action\n  saveField(id: string, currentValue: FieldValue) {\n    const oldValue = this.initialData[id];\n    const savePromise = this.saveFieldRequest(id, currentValue);\n\n    if (!savePromise) {\n      return null;\n    }\n\n    return savePromise\n      .then(resp => {\n        const newValue = this.getValue(id);\n        const change = {old: oldValue, new: newValue};\n\n        // Only use `allowUndo` option if explicitly defined\n        if (typeof this.options.allowUndo === 'undefined' || this.options.allowUndo) {\n          saveOnBlurUndoMessage(change, this, id);\n        }\n\n        if (this.options.onSubmitSuccess) {\n          this.options.onSubmitSuccess(resp, this, id, change);\n        }\n\n        return resp;\n      })\n      .catch(error => {\n        if (this.options.onSubmitError) {\n          this.options.onSubmitError(error, this, id);\n        }\n        return {};\n      });\n  }\n\n  /**\n   * Saves a field with new value\n   *\n   * If field has changes, field does not have errors, then it will:\n   * Save a snapshot, apply any data transforms, perform api request.\n   *\n   * If successful then: 1) reset save state, 2) update `initialData`, 3) save snapshot\n   * If failed then: 1) reset save state, 2) add error state\n   */\n  @action\n  saveFieldRequest(id: string, currentValue: FieldValue) {\n    const initialValue = this.initialData[id];\n\n    // Don't save if field hasn't changed\n    // Don't need to check for error state since initialData wouldn't have updated since last error\n    if (\n      currentValue === initialValue ||\n      (currentValue === '' && !defined(initialValue))\n    ) {\n      return null;\n    }\n\n    // Check for error first\n    this.validateField(id);\n    if (!this.isValidField(id)) {\n      return null;\n    }\n\n    // shallow clone fields\n    let saveSnapshot: SaveSnapshot = this.createSnapshot();\n\n    // Save field + value\n    this.setSaving(id, true);\n\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n\n    // Check if field needs to handle transforming request object\n    const getData =\n      typeof fieldDescriptor.getData === 'function' ? fieldDescriptor.getData : a => a;\n\n    const request = this.doApiRequest({\n      data: getData(\n        {[id]: this.getTransformedValue(id)},\n        {model: this, id, form: this.getData()}\n      ),\n    });\n\n    request\n      .then(data => {\n        this.setSaving(id, false);\n\n        // save snapshot\n        if (saveSnapshot) {\n          saveSnapshot();\n          saveSnapshot = null;\n        }\n\n        // Update initialData after successfully saving a field as it will now be the baseline value\n        this.initialData[id] = this.getValue(id);\n\n        return data;\n      })\n      .catch(resp => {\n        // should we revert field value to last known state?\n        saveSnapshot = null;\n\n        // Field can be configured to reset on error\n        // e.g. BooleanFields\n        const shouldReset = this.getDescriptor(id, 'resetOnError');\n        if (shouldReset) {\n          this.setValue(id, initialValue);\n        }\n\n        // API can return a JSON object with either:\n        // 1) map of {[fieldName] => Array<ErrorMessages>}\n        // 2) {'non_field_errors' => Array<ErrorMessages>}\n        if (resp && resp.responseJSON) {\n          // Show resp msg from API endpoint if possible\n          if (Array.isArray(resp.responseJSON[id]) && resp.responseJSON[id].length) {\n            // Just take first resp for now\n            this.setError(id, resp.responseJSON[id][0]);\n          } else if (\n            Array.isArray(resp.responseJSON.non_field_errors) &&\n            resp.responseJSON.non_field_errors.length\n          ) {\n            addErrorMessage(resp.responseJSON.non_field_errors[0], 10000);\n            // Reset saving state\n            this.setError(id, '');\n          } else {\n            this.setError(id, 'Failed to save');\n          }\n        } else {\n          // Default error behavior\n          this.setError(id, 'Failed to save');\n        }\n\n        // eslint-disable-next-line no-console\n        console.error('Error saving form field', resp && resp.responseJSON);\n      });\n\n    return request;\n  }\n\n  /**\n   * This is called when a field is blurred\n   *\n   * If `saveOnBlur` is set then call `saveField` and handle form callbacks accordingly\n   */\n  @action\n  handleBlurField(id: string, currentValue: FieldValue) {\n    // Nothing to do if `saveOnBlur` is not on\n    if (!this.options.saveOnBlur) {\n      return null;\n    }\n\n    // Fields can individually set `saveOnBlur` to `false` (note this is ignored when `undefined`)\n    const saveOnBlurFieldOverride = this.getDescriptor(id, 'saveOnBlur');\n    if (typeof saveOnBlurFieldOverride !== 'undefined' && !saveOnBlurFieldOverride) {\n      return null;\n    }\n\n    return this.saveField(id, currentValue);\n  }\n\n  @action\n  setFormSaving() {\n    this.formState = FormState.SAVING;\n  }\n\n  /**\n   * This is called when a field does not saveOnBlur and has an individual \"Save\" button\n   */\n  @action\n  handleSaveField(id: string, currentValue: FieldValue) {\n    const savePromise = this.saveField(id, currentValue);\n\n    if (!savePromise) {\n      return null;\n    }\n\n    return savePromise.then(() => {\n      this.setFieldState(id, 'showSave', false);\n    });\n  }\n\n  /**\n   * Cancel \"Save Field\" state and revert form value back to initial value\n   */\n  @action\n  handleCancelSaveField(id: string) {\n    this.setValue(id, this.initialData[id]);\n    this.setFieldState(id, 'showSave', false);\n  }\n\n  @action\n  setFieldState(id: string, key: string, value: FieldValue) {\n    const state = {\n      ...(this.fieldState.get(id) || {}),\n      [key]: value,\n    };\n    this.fieldState.set(id, state);\n  }\n\n  /**\n   * Set \"saving\" state for field\n   */\n  @action\n  setSaving(id: string, value: FieldValue) {\n    // When saving, reset error state\n    this.setError(id, false);\n    this.setFieldState(id, FormState.SAVING, value);\n    this.setFieldState(id, FormState.READY, !value);\n  }\n\n  /**\n   * Set \"error\" state for field\n   */\n  @action\n  setError(id: string, error: boolean | string) {\n    // Note we don't keep error in `this.fieldState` so that we can easily\n    // See if the form is in an \"error\" state with the `isError` getter\n    if (!!error) {\n      this.formState = FormState.ERROR;\n      this.errors.set(id, error);\n    } else {\n      this.formState = FormState.READY;\n      this.errors.delete(id);\n    }\n\n    // Field should no longer to \"saving\", but is not necessarily \"ready\"\n    this.setFieldState(id, FormState.SAVING, false);\n  }\n\n  /**\n   * Returns true if there are no errors\n   */\n  @action\n  validateForm(): boolean {\n    Array.from(this.fieldDescriptor.keys()).forEach(id => !this.validateField(id));\n\n    return !this.isError;\n  }\n\n  @action\n  handleErrorResponse({responseJSON: resp}: {responseJSON?: any} = {}) {\n    if (!resp) {\n      return;\n    }\n\n    // Show resp msg from API endpoint if possible\n    Object.keys(resp).forEach(id => {\n      if (\n        id === 'non_field_errors' &&\n        Array.isArray(resp.non_field_errors) &&\n        resp.non_field_errors.length\n      ) {\n        addErrorMessage(resp.non_field_errors[0], 10000);\n      } else if (Array.isArray(resp[id]) && resp[id].length) {\n        // Just take first resp for now\n        this.setError(id, resp[id][0]);\n      }\n    });\n  }\n\n  @action\n  submitSuccess(data: object) {\n    // update initial data\n    this.formState = FormState.READY;\n    this.initialData = data;\n  }\n\n  @action\n  submitError(err: {responseJSON?: any}) {\n    this.formState = FormState.ERROR;\n    this.formErrors = this.mapFormErrors(err.responseJSON);\n    this.handleErrorResponse({responseJSON: this.formErrors});\n  }\n\n  mapFormErrors(responseJSON?: any) {\n    return responseJSON;\n  }\n}\n\nexport default FormModel;\n","import React from 'react';\nimport InputField from 'app/views/settings/components/forms/inputField';\n\nexport default class TextField extends React.Component {\n  static propTypes = {\n    ...InputField.propTypes,\n  };\n\n  render() {\n    return <InputField {...this.props} type=\"text\" />;\n  }\n}\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport styled from 'react-emotion';\n\ntype Props = {\n  className?: string;\n  id?: string;\n  size?: 'sm' | 'lg';\n  isActive?: boolean;\n  isLoading?: boolean;\n  isDisabled?: boolean;\n  toggle: React.HTMLProps<HTMLButtonElement>['onClick'];\n};\n\nconst Switch: React.FC<Props> = ({\n  size,\n  isActive,\n  isLoading,\n  isDisabled,\n  toggle,\n  id,\n  className,\n}) => (\n  <SwitchButton\n    id={id}\n    type=\"button\"\n    className={className}\n    onClick={isDisabled ? undefined : toggle}\n    role=\"checkbox\"\n    aria-checked={isActive}\n    isLoading={isLoading}\n    isDisabled={isDisabled}\n    isActive={isActive}\n    size={size}\n    data-test-id=\"switch\"\n  >\n    <Toggle isDisabled={isDisabled} isActive={isActive} size={size} />\n  </SwitchButton>\n);\n\nSwitch.propTypes = {\n  id: PropTypes.string,\n  size: PropTypes.oneOf(['sm', 'lg']),\n  isActive: PropTypes.bool,\n  isLoading: PropTypes.bool,\n  isDisabled: PropTypes.bool,\n  toggle: PropTypes.func.isRequired,\n};\n\nSwitch.defaultProps = {\n  size: 'sm',\n};\n\ntype StyleProps = Partial<Props>;\n\nconst getSize = (p: StyleProps) => (p.size === 'sm' ? 16 : 24);\nconst getToggleSize = (p: StyleProps) => getSize(p) - (p.size === 'sm' ? 6 : 10);\nconst getToggleTop = (p: StyleProps) => (p.size === 'sm' ? 2 : 4);\nconst getTranslateX = (p: StyleProps) =>\n  p.isActive ? getToggleTop(p) + getSize(p) : getToggleTop(p);\n\nconst SwitchButton = styled('button')<StyleProps>`\n  display: inline-block;\n  background: none;\n  padding: 0;\n  border: 1px solid ${p => (p.isActive ? p.theme.borderDark : p.theme.borderLight)};\n  position: relative;\n  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.04);\n  transition: 0.15s border ease;\n  cursor: ${p => (p.isLoading || p.isDisabled ? 'not-allowed' : 'pointer')};\n  pointer-events: ${p => (p.isLoading || p.isDisabled ? 'none' : null)};\n  height: ${getSize}px;\n  width: ${p => getSize(p) * 2}px;\n  border-radius: ${getSize}px;\n\n  &:hover,\n  &:focus {\n    outline: none;\n    border-color: ${p => p.theme.borderDark};\n  }\n\n  &:focus,\n  &.focus-visible {\n    outline: none;\n    box-shadow: rgba(209, 202, 216, 0.5) 0 0 0 3px;\n  }\n`;\n\nconst Toggle = styled('span')<StyleProps>`\n  display: block;\n  position: absolute;\n  border-radius: 50%;\n  transition: 0.25s all ease;\n  top: ${getToggleTop}px;\n  transform: translateX(${getTranslateX}px);\n  width: ${getToggleSize}px;\n  height: ${getToggleSize}px;\n  background: ${p => (p.isActive ? p.theme.green : p.theme.gray6)};\n  opacity: ${p => (p.isDisabled ? 0.4 : null)};\n`;\nexport default Switch;\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\nimport InputField from 'app/views/settings/components/forms/inputField';\nimport Switch from 'app/components/switch';\nimport Confirm from 'app/components/confirm';\n\nexport default class BooleanField extends InputField {\n  static propTypes = {\n    ...InputField.propTypes,\n    confirm: PropTypes.shape({\n      true: PropTypes.node,\n      false: PropTypes.node,\n    }),\n  };\n  coerceValue(value) {\n    return value ? true : false;\n  }\n\n  handleChange = (value, onChange, onBlur, e) => {\n    // We need to toggle current value because Switch is not an input\n    const newValue = this.coerceValue(!value);\n    onChange(newValue, e);\n    onBlur(newValue, e);\n  };\n\n  render() {\n    const {confirm, ...fieldProps} = this.props;\n\n    return (\n      <InputField\n        {...fieldProps}\n        resetOnError\n        field={({onChange, onBlur, value, disabled, ...props}) => {\n          // Create a function with required args bound\n          const handleChange = this.handleChange.bind(this, value, onChange, onBlur);\n\n          const switchProps = {\n            size: 'lg',\n            ...props,\n            isActive: !!value,\n            isDisabled: disabled,\n            toggle: handleChange,\n          };\n\n          if (confirm) {\n            return (\n              <Confirm\n                renderMessage={() => confirm[!value]}\n                onConfirm={() => handleChange({})}\n              >\n                {({open}) => (\n                  <Switch\n                    {...switchProps}\n                    toggle={e => {\n                      // If we have a `confirm` prop and enabling switch\n                      // Then show confirm dialog, otherwise propagate change as normal\n                      if (confirm[!value]) {\n                        // Open confirm modal\n                        open();\n                        return;\n                      }\n\n                      handleChange(e);\n                    }}\n                  />\n                )}\n              </Confirm>\n            );\n          }\n\n          return <Switch {...switchProps} />;\n        }}\n      />\n    );\n  }\n}\n"],"sourceRoot":""}