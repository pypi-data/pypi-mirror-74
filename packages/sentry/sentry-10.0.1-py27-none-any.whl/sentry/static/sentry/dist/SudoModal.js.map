{"version":3,"sources":["webpack:///./app/components/u2f/u2fContainer.jsx","webpack:///./app/components/modals/sudoModal.jsx","webpack:///./app/views/settings/components/forms/form.tsx","webpack:///./app/views/settings/components/forms/model.tsx"],"names":["U2fContainer","props","state","authenticators","api","Client","this","requestPromise","then","resp","setState","clear","className","length","map","id","other","challenge","key","challengeData","React","Component","SudoModal","args","handleSuccess","closeModal","superuser","router","retryRequest","replace","getCurrentLocation","forceUpdate","Date","busy","handleError","error","handleU2fTap","data","method","err","user","Header","Body","Fragment","closeButton","onHide","t","hasPasswordAuth","marginBottom","space","type","icon","apiMethod","apiEndpoint","submitLabel","onSubmit","handleSubmit","onSubmitSuccess","onSubmitError","hideErrors","resetOnError","hideFooter","autoFocus","inline","label","flexibleControlStateSize","name","paddingLeft","paddingRight","borderBottom","displayMode","onTap","priority","href","encodeURIComponent","location","pathname","SudoModalContainer","createReactClass","displayName","render","ConfigStore","get","withApi","withRouter","context","model","e","preventDefault","isSaving","getData","saveForm","submitSuccess","submitError","saveOnBlur","onFieldChange","initialData","allowUndo","setInitialData","setFormOptions","getChildContext","form","componentWillUnmount","reset","children","footerClass","footerStyle","submitDisabled","submitPriority","cancelLabel","onCancel","extraButton","requireChanges","shouldShowFooter","StyledFooter","style","DefaultButtons","disabled","onClick","marginLeft","isError","formChanged","propTypes","string","func","bool","object","element","childContextTypes","isRequired","defaultProps","p","fields","errors","Map","fieldState","fieldDescriptor","snapshots","options","resetForm","toJSON","formState","SAVING","size","entries","setFieldDescriptor","set","defaultValue","setValue","removeField","createSnapshot","snapshot","unshift","getDescriptor","descriptor","has","getFieldState","getValue","getTransformedValue","transformer","value","getTransformedData","Object","keys","reduce","acc","getError","isValidRequiredField","isValidField","doApiRequest","endpoint","Promise","resolve","reject","request","success","response","Error","finalValue","transformInput","validateField","updateShowSaveState","updateShowReturnButtonState","validate","fieldIsRequiredMessage","push","forEach","field","errorMessage","setError","isValueChanged","saveOnBlurFieldOverride","setFieldState","undo","shift","validateForm","saveSnapshot","setFormSaving","saveField","currentValue","oldValue","savePromise","saveFieldRequest","newValue","change","old","new","initialValue","setSaving","a","responseJSON","Array","isArray","non_field_errors","console","handleBlurField","handleSaveField","handleCancelSaveField","READY","ERROR","from","handleErrorResponse","formErrors","mapFormErrors"],"mappings":"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","file":"SudoModal.js","sourcesContent":["import React from 'react';\n\nimport {Client} from 'app/api';\nimport U2fSign from './u2fsign';\n\nclass U2fContainer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      authenticators: null,\n    };\n    this.api = new Client();\n  }\n\n  componentDidMount() {\n    this.api\n      .requestPromise('/authenticators/')\n      .then(resp => {\n        this.setState({\n          authenticators: resp || [],\n        });\n      })\n      .catch(() => {\n        // ignore errors\n      });\n  }\n\n  componentWillUnmount() {\n    this.api.clear();\n    this.api = null;\n  }\n\n  render() {\n    const {className, authenticators} = this.state;\n    if (authenticators && authenticators.length) {\n      return (\n        <div className={className}>\n          {authenticators.map(({id, ...other}) => {\n            if (id === 'u2f' && other.challenge) {\n              return <U2fSign key={id} {...this.props} challengeData={other.challenge} />;\n            }\n\n            return null;\n          })}\n        </div>\n      );\n    }\n\n    return null;\n  }\n}\n\nexport default U2fContainer;\n","import {withRouter} from 'react-router';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport createReactClass from 'create-react-class';\n\nimport {t} from 'app/locale';\nimport Alert from 'app/components/alert';\nimport withApi from 'app/utils/withApi';\nimport Button from 'app/components/button';\nimport ConfigStore from 'app/stores/configStore';\nimport Form from 'app/views/settings/components/forms/form';\nimport InputField from 'app/views/settings/components/forms/inputField';\nimport TextBlock from 'app/views/settings/components/text/textBlock';\nimport U2fContainer from 'app/components/u2f/u2fContainer';\nimport space from 'app/styles/space';\n\nclass SudoModal extends React.Component {\n  static propTypes = {\n    api: PropTypes.object,\n    closeModal: PropTypes.func.isRequired,\n    /**\n     * expects a function that returns a Promise\n     */\n    retryRequest: PropTypes.func,\n\n    // User is a superuser without an active su session\n    superuser: PropTypes.bool,\n    router: PropTypes.object,\n    user: PropTypes.object,\n\n    Header: PropTypes.oneOfType([PropTypes.func, PropTypes.node]).isRequired,\n    Body: PropTypes.oneOfType([PropTypes.func, PropTypes.node]).isRequired,\n  };\n\n  constructor(...args) {\n    super(...args);\n    this.state = {\n      error: false,\n      busy: false,\n    };\n  }\n\n  handleSuccess = () => {\n    const {closeModal, superuser, router, retryRequest} = this.props;\n\n    if (!retryRequest) {\n      closeModal();\n      return;\n    }\n\n    if (superuser) {\n      router.replace({...router.getCurrentLocation(), state: {forceUpdate: new Date()}});\n      return;\n    }\n\n    this.setState(\n      {\n        busy: true,\n      },\n      () => {\n        retryRequest().then(() => {\n          this.setState(\n            {\n              busy: false,\n            },\n            closeModal\n          );\n        });\n      }\n    );\n  };\n\n  handleError = () => {\n    this.setState({\n      busy: false,\n      error: true,\n    });\n  };\n\n  handleU2fTap = data => {\n    this.setState({busy: true});\n    // u2Interface expects this to return a promise\n    return this.props.api\n      .requestPromise('/auth/', {\n        method: 'PUT',\n        data,\n      })\n      .then(() => {\n        this.handleSuccess();\n      })\n      .catch(err => {\n        this.setState({busy: false});\n\n        // u2fInterface relies on this\n        throw err;\n      });\n  };\n\n  render() {\n    const {closeModal, superuser, user, Header, Body} = this.props;\n\n    return (\n      <React.Fragment>\n        <Header closeButton onHide={closeModal}>\n          {t('Confirm Password to Continue')}\n        </Header>\n\n        <Body>\n          {!user.hasPasswordAuth ? (\n            <div>\n              <TextBlock>{t('You will need to reauthenticate to continue.')}</TextBlock>\n              <Button\n                priority=\"primary\"\n                href={`/auth/login/?next=${encodeURIComponent(location.pathname)}`}\n              >\n                {t('Continue')}\n              </Button>\n            </div>\n          ) : (\n            <React.Fragment>\n              <TextBlock css={{marginBottom: space(1)}}>\n                {superuser\n                  ? t(\n                      'You are attempting to access a resource that requires superuser access, please re-authenticate as a superuser.'\n                    )\n                  : t('Help us keep your account safe by confirming your identity.')}\n              </TextBlock>\n\n              {this.state.error && (\n                <Alert\n                  css={{marginBottom: 0}}\n                  type=\"error\"\n                  icon=\"icon-circle-exclamation\"\n                >\n                  {t('Incorrect password')}\n                </Alert>\n              )}\n\n              <Form\n                apiMethod=\"PUT\"\n                apiEndpoint=\"/auth/\"\n                submitLabel={t('Confirm Password')}\n                onSubmit={this.handleSubmit}\n                onSubmitSuccess={this.handleSuccess}\n                onSubmitError={this.handleError}\n                hideErrors\n                resetOnError\n                hideFooter={!user.hasPasswordAuth}\n              >\n                <InputField\n                  autoFocus\n                  type=\"password\"\n                  inline={false}\n                  label={t('Password')}\n                  flexibleControlStateSize\n                  name=\"password\"\n                  css={{\n                    paddingLeft: 0,\n                    paddingRight: 0,\n                    borderBottom: 'none',\n                  }}\n                />\n                <U2fContainer displayMode=\"sudo\" onTap={this.handleU2fTap} />\n              </Form>\n            </React.Fragment>\n          )}\n        </Body>\n      </React.Fragment>\n    );\n  }\n}\n\nconst SudoModalContainer = createReactClass({\n  displayName: 'SudoModalContainer',\n\n  render() {\n    const user = ConfigStore.get('user');\n    return <SudoModal {...this.props} user={user} />;\n  },\n});\n\nexport default withApi(withRouter(SudoModalContainer));\nexport {SudoModal};\n","import {Observer} from 'mobx-react';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport styled from 'react-emotion';\n\nimport {APIRequestMethod} from 'app/api';\nimport {t} from 'app/locale';\nimport Button from 'app/components/button';\nimport FormModel, {\n  FormOptions,\n  FieldValue,\n} from 'app/views/settings/components/forms/model';\nimport Panel from 'app/components/panels/panel';\nimport space from 'app/styles/space';\n\ntype Data = {};\n\ntype RenderProps = {\n  model: FormModel;\n};\n\ntype RenderFunc = (props: RenderProps) => React.ReactNode;\n\n// Type guard for render func.\nfunction isRenderFunc(func: React.ReactNode | Function): func is RenderFunc {\n  return typeof func === 'function';\n}\n\ntype Props = {\n  apiMethod?: APIRequestMethod;\n  apiEndpoint?: string;\n  children: React.ReactNode | RenderFunc;\n  className?: string;\n  cancelLabel?: string;\n  submitDisabled?: boolean;\n  submitLabel?: string;\n  submitPriority?: Button['props']['priority'];\n  footerClass?: string;\n  footerStyle?: React.CSSProperties;\n  extraButton?: React.ReactNode;\n  initialData?: Data;\n  // Require changes before able to submit form\n  requireChanges?: boolean;\n  // Reset form when there are errors; after submit\n  resetOnError?: boolean;\n  hideFooter?: boolean;\n  allowUndo?: boolean;\n  // Save field on control blur\n  saveOnBlur?: boolean;\n  model?: FormModel;\n  'data-test-id'?: string;\n\n  onCancel?: (e: React.MouseEvent) => void;\n  onSubmit?: (\n    data: Data,\n    onSubmitSuccess: (data: Data) => void,\n    onSubmitError: (error: any) => void,\n    e: React.FormEvent,\n    model: FormModel\n  ) => void;\n} & Pick<FormOptions, 'onSubmitSuccess' | 'onSubmitError' | 'onFieldChange'>;\n\ntype Context = {\n  saveOnBlur: boolean;\n  form: FormModel;\n};\n\nexport default class Form extends React.Component<Props> {\n  static propTypes: any = {\n    cancelLabel: PropTypes.string,\n    onCancel: PropTypes.func,\n    onSubmit: PropTypes.func,\n    onSubmitSuccess: PropTypes.func,\n    onSubmitError: PropTypes.func,\n    onFieldChange: PropTypes.func,\n    submitDisabled: PropTypes.bool,\n    submitLabel: PropTypes.string,\n    submitPriority: PropTypes.string,\n    footerClass: PropTypes.string,\n    footerStyle: PropTypes.object,\n    extraButton: PropTypes.element,\n    initialData: PropTypes.object,\n    // Require changes before able to submit form\n    requireChanges: PropTypes.bool,\n    // Reset form when there are errors, after submit\n    resetOnError: PropTypes.bool,\n    hideFooter: PropTypes.bool,\n    allowUndo: PropTypes.bool,\n    // Save field on control blur\n    saveOnBlur: PropTypes.bool,\n    model: PropTypes.object,\n    apiMethod: PropTypes.string,\n    apiEndpoint: PropTypes.string,\n    'data-test-id': PropTypes.string,\n  };\n\n  static childContextTypes = {\n    saveOnBlur: PropTypes.bool.isRequired,\n    form: PropTypes.object.isRequired,\n  };\n\n  static defaultProps = {\n    cancelLabel: t('Cancel'),\n    submitLabel: t('Save Changes'),\n    submitDisabled: false,\n    submitPriority: 'primary' as 'primary',\n    className: 'form-stacked',\n    requireChanges: false,\n    allowUndo: false,\n    saveOnBlur: false,\n  };\n\n  constructor(props: Props, context: Context) {\n    super(props, context);\n    const {\n      saveOnBlur,\n      apiEndpoint,\n      apiMethod,\n      resetOnError,\n      onSubmitSuccess,\n      onSubmitError,\n      onFieldChange,\n      initialData,\n      allowUndo,\n    } = props;\n\n    this.model.setInitialData(initialData);\n    this.model.setFormOptions({\n      resetOnError,\n      allowUndo,\n      onFieldChange,\n      onSubmitSuccess,\n      onSubmitError,\n      saveOnBlur,\n      apiEndpoint,\n      apiMethod,\n    });\n  }\n\n  getChildContext() {\n    return {\n      saveOnBlur: this.props.saveOnBlur,\n      form: this.model,\n    };\n  }\n\n  componentWillUnmount() {\n    this.model.reset();\n  }\n\n  model: FormModel = this.props.model || new FormModel();\n\n  onSubmit = e => {\n    e.preventDefault();\n    if (this.model.isSaving) {\n      return;\n    }\n\n    if (this.props.onSubmit) {\n      this.props.onSubmit(\n        this.model.getData(),\n        this.onSubmitSuccess,\n        this.onSubmitError,\n        e,\n        this.model\n      );\n    } else {\n      this.model.saveForm();\n    }\n  };\n\n  onSubmitSuccess = data => {\n    const {onSubmitSuccess} = this.props;\n    this.model.submitSuccess(data);\n\n    if (onSubmitSuccess) {\n      onSubmitSuccess(data, this.model);\n    }\n  };\n\n  onSubmitError = error => {\n    const {onSubmitError} = this.props;\n    this.model.submitError(error);\n\n    if (onSubmitError) {\n      onSubmitError(error, this.model);\n    }\n  };\n\n  render() {\n    const {\n      className,\n      children,\n      footerClass,\n      footerStyle,\n      submitDisabled,\n      submitLabel,\n      submitPriority,\n      cancelLabel,\n      onCancel,\n      extraButton,\n      requireChanges,\n      saveOnBlur,\n      hideFooter,\n    } = this.props;\n    const shouldShowFooter =\n      typeof hideFooter !== 'undefined' ? !hideFooter : !saveOnBlur;\n\n    return (\n      <form\n        onSubmit={this.onSubmit}\n        className={className}\n        data-test-id={this.props['data-test-id']}\n      >\n        <div>{isRenderFunc(children) ? children({model: this.model}) : children}</div>\n\n        {shouldShowFooter && (\n          <StyledFooter\n            className={footerClass}\n            style={footerStyle}\n            saveOnBlur={saveOnBlur}\n          >\n            {extraButton}\n            <DefaultButtons>\n              {onCancel && (\n                <Observer>\n                  {() => (\n                    <Button\n                      type=\"button\"\n                      disabled={this.model.isSaving}\n                      onClick={onCancel}\n                      style={{marginLeft: 5}}\n                    >\n                      {cancelLabel}\n                    </Button>\n                  )}\n                </Observer>\n              )}\n\n              <Observer>\n                {() => (\n                  <Button\n                    data-test-id=\"form-submit\"\n                    priority={submitPriority}\n                    disabled={\n                      this.model.isError ||\n                      this.model.isSaving ||\n                      submitDisabled ||\n                      (requireChanges ? !this.model.formChanged : false)\n                    }\n                    type=\"submit\"\n                  >\n                    {submitLabel}\n                  </Button>\n                )}\n              </Observer>\n            </DefaultButtons>\n          </StyledFooter>\n        )}\n      </form>\n    );\n  }\n}\n\nconst StyledFooter = styled('div')<{saveOnBlur?: boolean}>`\n  display: flex;\n  justify-content: flex-end;\n  margin-top: 25px;\n  border-top: 1px solid #e9ebec;\n  background: none;\n  padding: 16px 0 0;\n  margin-bottom: 16px;\n\n  ${p =>\n    !p.saveOnBlur &&\n    `\n  ${Panel} & {\n    margin-top: 0;\n    padding-right: 36px;\n  }\n\n  /* Better padding with form inside of a modal */\n  .modal-content & {\n    padding-right: 30px;\n    margin-left: -30px;\n    margin-right: -30px;\n    margin-bottom: -30px;\n    margin-top: 16px;\n    padding-bottom: 16px;\n  }\n  `};\n`;\n\nconst DefaultButtons = styled('div')`\n  display: grid;\n  grid-gap: ${space(1)};\n  grid-auto-flow: column;\n  justify-content: flex-end;\n  flex: 1;\n`;\n\nexport {FieldValue};\n","import {observable, computed, action, ObservableMap} from 'mobx';\nimport isEqual from 'lodash/isEqual';\n\nimport {Client, APIRequestMethod} from 'app/api';\nimport {addErrorMessage, saveOnBlurUndoMessage} from 'app/actionCreators/indicator';\nimport {defined} from 'app/utils';\nimport {t} from 'app/locale';\nimport FormState from 'app/components/forms/state';\n\ntype Snapshot = Map<string, FieldValue>;\ntype SaveSnapshot = (() => number) | null;\n\nexport type FieldValue = string | number | boolean | undefined; //is undefined valid here?\n\nexport type FormOptions = {\n  apiEndpoint?: string;\n  apiMethod?: APIRequestMethod;\n  allowUndo?: boolean;\n  resetOnError?: boolean;\n  saveOnBlur?: boolean;\n  onFieldChange?: (id: string, finalValue: FieldValue) => void;\n  onSubmitSuccess?: (\n    response: any,\n    instance: FormModel,\n    id?: string,\n    change?: {old: FieldValue; new: FieldValue}\n  ) => void;\n  onSubmitError?: (error: any, instance: FormModel, id?: string) => void;\n};\n\ntype OptionsWithInitial = FormOptions & {initialData?: object};\n\nclass FormModel {\n  /**\n   * Map of field name -> value\n   */\n  fields: ObservableMap<string, FieldValue> = observable.map();\n\n  /**\n   * Errors for individual fields\n   * Note we don't keep error in `this.fieldState` so that we can easily\n   * See if the form is in an \"error\" state with the `isError` getter\n   */\n  @observable errors = new Map();\n\n  /**\n   * State of individual fields\n   *\n   * Map of field name -> object\n   */\n\n  @observable fieldState = new Map();\n\n  /**\n   * State of the form as a whole\n   */\n  @observable formState;\n\n  /**\n   * Holds field properties as declared in <Form>\n   * Does not need to be observable since these props should never change\n   */\n  fieldDescriptor = new Map();\n\n  /**\n   * Holds a list of `fields` states\n   */\n  snapshots: Array<Snapshot> = [];\n\n  /**\n   * POJO of field name -> value\n   * It holds field values \"since last save\"\n   */\n  initialData = {};\n\n  api: Client | null;\n\n  formErrors: any;\n\n  options: FormOptions;\n\n  constructor({initialData, ...options}: OptionsWithInitial = {}) {\n    this.options = options || {};\n    if (initialData) {\n      this.setInitialData(initialData);\n    }\n\n    this.api = new Client();\n  }\n\n  /**\n   * Reset state of model\n   */\n  reset() {\n    this.api && this.api.clear();\n    this.api = null;\n    this.fieldDescriptor.clear();\n    this.resetForm();\n  }\n\n  resetForm() {\n    this.fields.clear();\n    this.errors.clear();\n    this.fieldState.clear();\n    this.snapshots = [];\n    this.initialData = {};\n  }\n\n  /**\n   * Deep equality comparison between last saved state and current fields state\n   */\n  @computed\n  get formChanged() {\n    return !isEqual(this.initialData, this.fields.toJSON());\n  }\n\n  @computed\n  get formData() {\n    return this.fields;\n  }\n\n  /** Is form saving */\n  @computed\n  get isSaving() {\n    return this.formState === FormState.SAVING;\n  }\n\n  /** Does form have any errors */\n  @computed\n  get isError() {\n    return !!this.errors.size;\n  }\n\n  /**\n   * Sets initial form data\n   *\n   * Also resets snapshots\n   */\n  setInitialData(initialData?: object) {\n    this.fields.replace(initialData || {});\n    this.initialData = this.fields.toJSON() || {};\n\n    this.snapshots = [new Map(this.fields.entries())];\n  }\n\n  /**\n   * Set form options\n   */\n  setFormOptions(options: FormOptions) {\n    this.options = options || {};\n  }\n\n  /**\n   * Set field properties\n   */\n  setFieldDescriptor(id: string, props) {\n    //TODO(TS): add type to props\n    this.fieldDescriptor.set(id, props);\n\n    // Set default value iff initialData for field is undefined\n    // This must take place before checking for `props.setValue` so that it can\n    // be applied to `defaultValue`\n    if (\n      typeof props.defaultValue !== 'undefined' &&\n      typeof this.initialData[id] === 'undefined'\n    ) {\n      this.initialData[id] =\n        typeof props.defaultValue === 'function'\n          ? props.defaultValue()\n          : props.defaultValue;\n\n      this.fields.set(id, this.initialData[id]);\n    }\n\n    if (typeof props.setValue === 'function') {\n      this.initialData[id] = props.setValue(this.initialData[id], props);\n      this.fields.set(id, this.initialData[id]);\n    }\n  }\n\n  /**\n   * Remove a field from the descriptor map and errors.\n   */\n  removeField(id: string) {\n    this.fieldDescriptor.delete(id);\n    this.errors.delete(id);\n  }\n\n  /**\n   * Creates a cloned Map of `this.fields` and returns a closure that when called\n   * will save Map to `snapshots\n   */\n  createSnapshot() {\n    const snapshot = new Map(this.fields.entries());\n    return () => this.snapshots.unshift(snapshot);\n  }\n\n  getDescriptor(id: string, key: string) {\n    // Needs to call `has` or else component will not be reactive if `id` doesn't exist in observable map\n    const descriptor = this.fieldDescriptor.has(id) && this.fieldDescriptor.get(id);\n    if (!descriptor) {\n      return null;\n    }\n\n    return descriptor[key];\n  }\n\n  getFieldState(id: string, key: string) {\n    // Needs to call `has` or else component will not be reactive if `id` doesn't exist in observable map\n    const fieldState = this.fieldState.has(id) && this.fieldState.get(id);\n    if (!fieldState) {\n      return null;\n    }\n\n    return fieldState[key];\n  }\n\n  getValue(id: string) {\n    if (!this.fields.has(id)) {\n      return '';\n    }\n\n    return this.fields.get(id);\n  }\n\n  getTransformedValue(id: string) {\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n    const transformer =\n      fieldDescriptor && typeof fieldDescriptor.getValue === 'function'\n        ? fieldDescriptor.getValue\n        : null;\n    const value = this.getValue(id);\n\n    return transformer ? transformer(value) : value;\n  }\n\n  /**\n   * Data represented in UI\n   */\n  getData() {\n    return this.fields.toJSON();\n  }\n\n  /**\n   * Form data that will be sent to API endpoint (i.e. after transforms)\n   */\n  getTransformedData() {\n    const form = this.getData();\n\n    return Object.keys(form)\n      .map(id => [id, this.getTransformedValue(id)])\n      .reduce((acc, [id, value]) => {\n        acc[id] = value;\n        return acc;\n      }, {});\n  }\n\n  getError(id: string) {\n    return this.errors.has(id) && this.errors.get(id);\n  }\n\n  // Returns true if not required or is required and is not empty\n  isValidRequiredField(id: string) {\n    // Check field descriptor to see if field is required\n    const isRequired = this.getDescriptor(id, 'required');\n    const value = this.getValue(id);\n    return !isRequired || (value !== '' && defined(value));\n  }\n\n  isValidField(id: string) {\n    return (this.getError(id) || []).length === 0;\n  }\n\n  doApiRequest({\n    apiEndpoint,\n    apiMethod,\n    data,\n  }: {\n    apiEndpoint?: string;\n    apiMethod?: APIRequestMethod;\n    data: object;\n  }) {\n    const endpoint = apiEndpoint || this.options.apiEndpoint || '';\n    const method = apiMethod || this.options.apiMethod;\n\n    return new Promise((resolve, reject) => {\n      //should never happen but TS complains if we don't check\n      if (!this.api) {\n        return reject(new Error('Api not set'));\n      }\n      return this.api.request(endpoint, {\n        method,\n        data,\n        success: response => resolve(response),\n        error: error => reject(error),\n      });\n    });\n  }\n\n  @action\n  setValue(id: string, value: FieldValue) {\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n    let finalValue = value;\n\n    if (fieldDescriptor && typeof fieldDescriptor.transformInput === 'function') {\n      finalValue = fieldDescriptor.transformInput(value);\n    }\n\n    this.fields.set(id, finalValue);\n\n    if (this.options.onFieldChange) {\n      this.options.onFieldChange(id, finalValue);\n    }\n\n    this.validateField(id);\n    this.updateShowSaveState(id, finalValue);\n    this.updateShowReturnButtonState(id, finalValue);\n  }\n\n  @action\n  validateField(id: string) {\n    const validate = this.getDescriptor(id, 'validate');\n    let errors: any[] = [];\n\n    if (typeof validate === 'function') {\n      // Returns \"tuples\" of [id, error string]\n      errors = validate({model: this, id, form: this.getData()}) || [];\n    }\n\n    const fieldIsRequiredMessage = t('Field is required');\n\n    if (!this.isValidRequiredField(id)) {\n      errors.push([id, fieldIsRequiredMessage]);\n    }\n\n    // If we have no errors, ensure we clear the field\n    errors = errors.length === 0 ? [[id, null]] : errors;\n\n    errors.forEach(([field, errorMessage]) => this.setError(field, errorMessage));\n    return undefined;\n  }\n\n  @action\n  updateShowSaveState(id: string, value: FieldValue) {\n    const isValueChanged = value !== this.initialData[id];\n    // Update field state to \"show save\" if save on blur is disabled for this field\n    // (only if contents of field differs from initial value)\n    const saveOnBlurFieldOverride = this.getDescriptor(id, 'saveOnBlur');\n    if (typeof saveOnBlurFieldOverride === 'undefined' || saveOnBlurFieldOverride) {\n      return;\n    }\n    if (this.getFieldState(id, 'showSave') === isValueChanged) {\n      return;\n    }\n\n    this.setFieldState(id, 'showSave', isValueChanged);\n  }\n\n  @action\n  updateShowReturnButtonState(id: string, value: FieldValue) {\n    const isValueChanged = value !== this.initialData[id];\n    const shouldShowReturnButton = this.getDescriptor(id, 'showReturnButton');\n\n    if (!shouldShowReturnButton) {\n      return;\n    }\n    // Only update state if state has changed\n    if (this.getFieldState(id, 'showReturnButton') === isValueChanged) {\n      return;\n    }\n\n    this.setFieldState(id, 'showReturnButton', isValueChanged);\n  }\n\n  /**\n   * Changes form values to previous saved state\n   */\n  @action\n  undo() {\n    // Always have initial data snapshot\n    if (this.snapshots.length < 2) {\n      return null;\n    }\n\n    this.snapshots.shift();\n    this.fields.replace(this.snapshots[0]);\n\n    return true;\n  }\n\n  /**\n   * Attempts to save entire form to server and saves a snapshot for undos\n   */\n  @action\n  saveForm() {\n    if (!this.validateForm()) {\n      return null;\n    }\n\n    let saveSnapshot: SaveSnapshot = this.createSnapshot();\n\n    const request = this.doApiRequest({\n      data: this.getTransformedData(),\n    });\n\n    this.setFormSaving();\n    request\n      .then(resp => {\n        // save snapshot\n        if (saveSnapshot) {\n          saveSnapshot();\n          saveSnapshot = null;\n        }\n\n        if (this.options.onSubmitSuccess) {\n          this.options.onSubmitSuccess(resp, this);\n        }\n      })\n      .catch(resp => {\n        // should we revert field value to last known state?\n        saveSnapshot = null;\n        if (this.options.resetOnError) {\n          this.setInitialData({});\n        }\n        this.submitError(resp);\n        if (this.options.onSubmitError) {\n          this.options.onSubmitError(resp, this);\n        }\n      });\n\n    return request;\n  }\n\n  /**\n   * Attempts to save field and show undo message if necessary.\n   * Calls submit handlers.\n   * TODO(billy): This should return a promise that resolves (instead of null)\n   */\n  @action\n  saveField(id: string, currentValue: FieldValue) {\n    const oldValue = this.initialData[id];\n    const savePromise = this.saveFieldRequest(id, currentValue);\n\n    if (!savePromise) {\n      return null;\n    }\n\n    return savePromise\n      .then(resp => {\n        const newValue = this.getValue(id);\n        const change = {old: oldValue, new: newValue};\n\n        // Only use `allowUndo` option if explicitly defined\n        if (typeof this.options.allowUndo === 'undefined' || this.options.allowUndo) {\n          saveOnBlurUndoMessage(change, this, id);\n        }\n\n        if (this.options.onSubmitSuccess) {\n          this.options.onSubmitSuccess(resp, this, id, change);\n        }\n\n        return resp;\n      })\n      .catch(error => {\n        if (this.options.onSubmitError) {\n          this.options.onSubmitError(error, this, id);\n        }\n        return {};\n      });\n  }\n\n  /**\n   * Saves a field with new value\n   *\n   * If field has changes, field does not have errors, then it will:\n   * Save a snapshot, apply any data transforms, perform api request.\n   *\n   * If successful then: 1) reset save state, 2) update `initialData`, 3) save snapshot\n   * If failed then: 1) reset save state, 2) add error state\n   */\n  @action\n  saveFieldRequest(id: string, currentValue: FieldValue) {\n    const initialValue = this.initialData[id];\n\n    // Don't save if field hasn't changed\n    // Don't need to check for error state since initialData wouldn't have updated since last error\n    if (\n      currentValue === initialValue ||\n      (currentValue === '' && !defined(initialValue))\n    ) {\n      return null;\n    }\n\n    // Check for error first\n    this.validateField(id);\n    if (!this.isValidField(id)) {\n      return null;\n    }\n\n    // shallow clone fields\n    let saveSnapshot: SaveSnapshot = this.createSnapshot();\n\n    // Save field + value\n    this.setSaving(id, true);\n\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n\n    // Check if field needs to handle transforming request object\n    const getData =\n      typeof fieldDescriptor.getData === 'function' ? fieldDescriptor.getData : a => a;\n\n    const request = this.doApiRequest({\n      data: getData(\n        {[id]: this.getTransformedValue(id)},\n        {model: this, id, form: this.getData()}\n      ),\n    });\n\n    request\n      .then(data => {\n        this.setSaving(id, false);\n\n        // save snapshot\n        if (saveSnapshot) {\n          saveSnapshot();\n          saveSnapshot = null;\n        }\n\n        // Update initialData after successfully saving a field as it will now be the baseline value\n        this.initialData[id] = this.getValue(id);\n\n        return data;\n      })\n      .catch(resp => {\n        // should we revert field value to last known state?\n        saveSnapshot = null;\n\n        // Field can be configured to reset on error\n        // e.g. BooleanFields\n        const shouldReset = this.getDescriptor(id, 'resetOnError');\n        if (shouldReset) {\n          this.setValue(id, initialValue);\n        }\n\n        // API can return a JSON object with either:\n        // 1) map of {[fieldName] => Array<ErrorMessages>}\n        // 2) {'non_field_errors' => Array<ErrorMessages>}\n        if (resp && resp.responseJSON) {\n          // Show resp msg from API endpoint if possible\n          if (Array.isArray(resp.responseJSON[id]) && resp.responseJSON[id].length) {\n            // Just take first resp for now\n            this.setError(id, resp.responseJSON[id][0]);\n          } else if (\n            Array.isArray(resp.responseJSON.non_field_errors) &&\n            resp.responseJSON.non_field_errors.length\n          ) {\n            addErrorMessage(resp.responseJSON.non_field_errors[0], 10000);\n            // Reset saving state\n            this.setError(id, '');\n          } else {\n            this.setError(id, 'Failed to save');\n          }\n        } else {\n          // Default error behavior\n          this.setError(id, 'Failed to save');\n        }\n\n        // eslint-disable-next-line no-console\n        console.error('Error saving form field', resp && resp.responseJSON);\n      });\n\n    return request;\n  }\n\n  /**\n   * This is called when a field is blurred\n   *\n   * If `saveOnBlur` is set then call `saveField` and handle form callbacks accordingly\n   */\n  @action\n  handleBlurField(id: string, currentValue: FieldValue) {\n    // Nothing to do if `saveOnBlur` is not on\n    if (!this.options.saveOnBlur) {\n      return null;\n    }\n\n    // Fields can individually set `saveOnBlur` to `false` (note this is ignored when `undefined`)\n    const saveOnBlurFieldOverride = this.getDescriptor(id, 'saveOnBlur');\n    if (typeof saveOnBlurFieldOverride !== 'undefined' && !saveOnBlurFieldOverride) {\n      return null;\n    }\n\n    return this.saveField(id, currentValue);\n  }\n\n  @action\n  setFormSaving() {\n    this.formState = FormState.SAVING;\n  }\n\n  /**\n   * This is called when a field does not saveOnBlur and has an individual \"Save\" button\n   */\n  @action\n  handleSaveField(id: string, currentValue: FieldValue) {\n    const savePromise = this.saveField(id, currentValue);\n\n    if (!savePromise) {\n      return null;\n    }\n\n    return savePromise.then(() => {\n      this.setFieldState(id, 'showSave', false);\n    });\n  }\n\n  /**\n   * Cancel \"Save Field\" state and revert form value back to initial value\n   */\n  @action\n  handleCancelSaveField(id: string) {\n    this.setValue(id, this.initialData[id]);\n    this.setFieldState(id, 'showSave', false);\n  }\n\n  @action\n  setFieldState(id: string, key: string, value: FieldValue) {\n    const state = {\n      ...(this.fieldState.get(id) || {}),\n      [key]: value,\n    };\n    this.fieldState.set(id, state);\n  }\n\n  /**\n   * Set \"saving\" state for field\n   */\n  @action\n  setSaving(id: string, value: FieldValue) {\n    // When saving, reset error state\n    this.setError(id, false);\n    this.setFieldState(id, FormState.SAVING, value);\n    this.setFieldState(id, FormState.READY, !value);\n  }\n\n  /**\n   * Set \"error\" state for field\n   */\n  @action\n  setError(id: string, error: boolean | string) {\n    // Note we don't keep error in `this.fieldState` so that we can easily\n    // See if the form is in an \"error\" state with the `isError` getter\n    if (!!error) {\n      this.formState = FormState.ERROR;\n      this.errors.set(id, error);\n    } else {\n      this.formState = FormState.READY;\n      this.errors.delete(id);\n    }\n\n    // Field should no longer to \"saving\", but is not necessarily \"ready\"\n    this.setFieldState(id, FormState.SAVING, false);\n  }\n\n  /**\n   * Returns true if there are no errors\n   */\n  @action\n  validateForm(): boolean {\n    Array.from(this.fieldDescriptor.keys()).forEach(id => !this.validateField(id));\n\n    return !this.isError;\n  }\n\n  @action\n  handleErrorResponse({responseJSON: resp}: {responseJSON?: any} = {}) {\n    if (!resp) {\n      return;\n    }\n\n    // Show resp msg from API endpoint if possible\n    Object.keys(resp).forEach(id => {\n      if (\n        id === 'non_field_errors' &&\n        Array.isArray(resp.non_field_errors) &&\n        resp.non_field_errors.length\n      ) {\n        addErrorMessage(resp.non_field_errors[0], 10000);\n      } else if (Array.isArray(resp[id]) && resp[id].length) {\n        // Just take first resp for now\n        this.setError(id, resp[id][0]);\n      }\n    });\n  }\n\n  @action\n  submitSuccess(data: object) {\n    // update initial data\n    this.formState = FormState.READY;\n    this.initialData = data;\n  }\n\n  @action\n  submitError(err: {responseJSON?: any}) {\n    this.formState = FormState.ERROR;\n    this.formErrors = this.mapFormErrors(err.responseJSON);\n    this.handleErrorResponse({responseJSON: this.formErrors});\n  }\n\n  mapFormErrors(responseJSON?: any) {\n    return responseJSON;\n  }\n}\n\nexport default FormModel;\n"],"sourceRoot":""}