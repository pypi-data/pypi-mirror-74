{"version":3,"sources":["webpack:///./app/components/modals/createIncidentModal.jsx","webpack:///./app/views/settings/components/forms/form.tsx","webpack:///./app/views/settings/components/forms/model.tsx","webpack:///./app/views/settings/components/forms/textField.jsx","webpack:///./app/actionCreators/incident.jsx"],"names":["CreateIncidentModal","handleSubmit","data","onSuccess","onError","_e","model","a","async","props","api","organization","issues","setFormSaving","createIncident","title","incident","handleSuccess","onClose","closeModal","browserHistory","push","slug","identifier","this","Body","Header","Fragment","closeButton","onHide","t","data-test-id","submitLabel","onSubmit","onSubmitSuccess","requireChanges","initialData","date","Date","name","label","placeholder","help","required","stacked","inline","flexibleControlStateSize","React","Component","withApi","context","e","preventDefault","isSaving","getData","onSubmitError","saveForm","submitSuccess","error","submitError","saveOnBlur","apiEndpoint","apiMethod","resetOnError","onFieldChange","allowUndo","setInitialData","setFormOptions","getChildContext","form","componentWillUnmount","reset","render","className","children","footerClass","footerStyle","submitDisabled","submitPriority","cancelLabel","onCancel","extraButton","hideFooter","shouldShowFooter","StyledFooter","style","DefaultButtons","type","disabled","onClick","marginLeft","priority","isError","formChanged","propTypes","string","func","bool","object","element","childContextTypes","isRequired","defaultProps","p","fields","map","errors","Map","fieldState","fieldDescriptor","snapshots","options","clear","resetForm","toJSON","formState","SAVING","size","replace","entries","setFieldDescriptor","id","set","defaultValue","setValue","removeField","createSnapshot","snapshot","unshift","getDescriptor","key","descriptor","has","get","getFieldState","getValue","getTransformedValue","transformer","value","getTransformedData","Object","keys","reduce","acc","getError","isValidRequiredField","isValidField","length","doApiRequest","endpoint","method","Promise","resolve","reject","request","success","response","Error","finalValue","transformInput","validateField","updateShowSaveState","updateShowReturnButtonState","validate","fieldIsRequiredMessage","forEach","field","errorMessage","setError","isValueChanged","saveOnBlurFieldOverride","setFieldState","undo","shift","validateForm","saveSnapshot","then","resp","saveField","currentValue","oldValue","savePromise","saveFieldRequest","newValue","change","old","new","initialValue","setSaving","responseJSON","Array","isArray","non_field_errors","console","handleBlurField","handleSaveField","handleCancelSaveField","state","READY","ERROR","from","handleErrorResponse","err","formErrors","mapFormErrors","TextField","groups","addLoadingMessage","requestPromise","query","clearIndicators","addErrorMessage","fetchIncidentActivities","orgId","incidentId","createIncidentNote","note","mentions","comment","text","result","deleteIncidentNote","noteId","updateIncidentNote","markIncidentAsSeen","hasSeen"],"mappings":"6QAWMA,E,mLAWJC,aAAe,SAAOC,EAAMC,EAAWC,EAASC,EAAIC,GAArC,uBAAAC,EAAAC,OAAA,yDACuB,EAAKC,MAAlCC,EADM,EACNA,IAAKC,EADC,EACDA,aAAcC,EADb,EACaA,OAE1BN,EAAMO,gBAHO,oBAAAN,EAAA,MAMYO,YAAeJ,EAAKC,EAAcT,EAAKa,MAAOH,IAN1D,OAMLI,EANK,OAOXb,EAAUa,GAPC,gDASXZ,EAAQ,EAAD,IATI,yD,EAafa,cAAgB,SAAAf,GAAQ,MACsB,EAAKO,MAA1CE,EADe,EACfA,aAAcO,EADC,EACDA,QAASC,EADR,EACQA,WAE1BD,GACFA,EAAQhB,GAGViB,IAEIjB,GACFkB,iBAAeC,KAAf,yBACoBV,EAAaW,KADjC,sBACmDpB,EAAKqB,WADxD,O,wDAMK,MAC4BC,KAAKf,MAAjCgB,EADA,EACAA,KAAMC,EADN,EACMA,OAAQP,EADd,EACcA,WAErB,OACE,kBAAC,IAAMQ,SAAP,KACE,kBAACD,EAAD,CAAQE,aAAW,EAACC,OAAQV,GACzBW,YAAE,wBAEL,kBAACL,EAAD,KACE,kBAAC,IAAD,CACEM,eAAa,2BACbC,YAAaF,YAAE,mBACfG,SAAUT,KAAKvB,aACfiC,gBAAiBV,KAAKP,cACtBkB,gBAAc,EACdC,YAAa,CACXC,KAAM,IAAIC,OAGZ,kBAAC,IAAD,CACEC,KAAK,QACLC,MAAOV,YAAE,iBACTW,YAAaX,YAAE,iBACfY,KAAMZ,YAAE,6CACRa,UAAQ,EACRC,SAAO,EACPC,QAAQ,EACRC,0BAAwB,W,GAnEJC,IAAMC,WAAlChD,E,kCA4ESiD,sBAAQjD,I,uICpBvB,kBA6CE,WAAYS,EAAcyC,GAA1B,MACE,YAAMzC,EAAOyC,IAAQ,KAqCvB,EAAA5C,MAAmB,EAAKG,MAAMH,OAAS,IAAI,IAE3C,EAAA2B,SAAW,SAAAkB,GACTA,EAAEC,iBACE,EAAK9C,MAAM+C,WAIX,EAAK5C,MAAMwB,SACb,EAAKxB,MAAMwB,SACT,EAAK3B,MAAMgD,UACX,EAAKpB,gBACL,EAAKqB,cACLJ,EACA,EAAK7C,OAGP,EAAKA,MAAMkD,aAIf,EAAAtB,gBAAkB,SAAAhC,GACT,IAAAgC,EAAA,QAAAA,gBACP,EAAK5B,MAAMmD,cAAcvD,GAErBgC,GACFA,EAAgBhC,EAAM,EAAKI,QAI/B,EAAAiD,cAAgB,SAAAG,GACP,IAAAH,EAAA,QAAAA,cACP,EAAKjD,MAAMqD,YAAYD,GAEnBH,GACFA,EAAcG,EAAO,EAAKpD,QAtE1B,IAAAsD,EAAA,EAAAA,WACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,UACAC,EAAA,EAAAA,aACA7B,EAAA,EAAAA,gBACAqB,EAAA,EAAAA,cACAS,EAAA,EAAAA,cACA5B,EAAA,EAAAA,YACA6B,EAAA,EAAAA,U,OAGF,EAAK3D,MAAM4D,eAAe9B,GAC1B,EAAK9B,MAAM6D,eAAe,CACxBJ,aAAY,EACZE,UAAS,EACTD,cAAa,EACb9B,gBAAe,EACfqB,cAAa,EACbK,WAAU,EACVC,YAAW,EACXC,UAAS,I,EA+Hf,OAnMkC,iBAwEhC,YAAAM,gBAAA,WACE,MAAO,CACLR,WAAYpC,KAAKf,MAAMmD,WACvBS,KAAM7C,KAAKlB,QAIf,YAAAgE,qBAAA,WACE9C,KAAKlB,MAAMiE,SA0Cb,YAAAC,OAAA,sBACQ,aACJC,EAAA,EAAAA,UACAC,EAAA,EAAAA,SACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,eACA7C,EAAA,EAAAA,YACA8C,EAAA,EAAAA,eACAC,EAAA,EAAAA,YACAC,EAAA,EAAAA,SACAC,EAAA,EAAAA,YACA9C,EAAA,EAAAA,eACAyB,EAAA,EAAAA,WACAsB,EAAA,EAAAA,WAEIC,OACkB,IAAfD,GAA8BA,GAActB,EAErD,OACE,0BACE3B,SAAUT,KAAKS,SACfwC,UAAWA,EAAS,eACNjD,KAAKf,MAAM,iBAEzB,6BA7LiB,mBA6LEiE,EAAYA,EAAS,CAACpE,MAAOkB,KAAKlB,QAAUoE,GAE9DS,GACC,kBAACC,EAAY,CACXX,UAAWE,EACXU,MAAOT,EACPhB,WAAYA,GAEXqB,EACD,kBAACK,EAAc,KACZN,GACC,kBAAC,IAAQ,MACN,WAAM,OACL,kBAAC,IAAM,CACLO,KAAK,SACLC,SAAU,EAAKlF,MAAM+C,SACrBoC,QAAST,EACTK,MAAO,CAACK,WAAY,IALjB,MAaX,kBAAC,IAAQ,MACN,WAAM,OACL,kBAAC,IAAM,gBACQ,cACbC,SAAUb,EACVU,SACE,EAAKlF,MAAMsF,SACX,EAAKtF,MAAM+C,UACXwB,KACC1C,IAAkB,EAAK7B,MAAMuF,YAEhCN,KAAK,UAVF,UA5Kd,EAAAO,UAAiB,CACtBf,YAAa,IAAUgB,OACvBf,SAAU,IAAUgB,KACpB/D,SAAU,IAAU+D,KACpB9D,gBAAiB,IAAU8D,KAC3BzC,cAAe,IAAUyC,KACzBhC,cAAe,IAAUgC,KACzBnB,eAAgB,IAAUoB,KAC1BjE,YAAa,IAAU+D,OACvBjB,eAAgB,IAAUiB,OAC1BpB,YAAa,IAAUoB,OACvBnB,YAAa,IAAUsB,OACvBjB,YAAa,IAAUkB,QACvB/D,YAAa,IAAU8D,OAEvB/D,eAAgB,IAAU8D,KAE1BlC,aAAc,IAAUkC,KACxBf,WAAY,IAAUe,KACtBhC,UAAW,IAAUgC,KAErBrC,WAAY,IAAUqC,KACtB3F,MAAO,IAAU4F,OACjBpC,UAAW,IAAUiC,OACrBlC,YAAa,IAAUkC,OACvB,eAAgB,IAAUA,QAGrB,EAAAK,kBAAoB,CACzBxC,WAAY,IAAUqC,KAAKI,WAC3BhC,KAAM,IAAU6B,OAAOG,YAGlB,EAAAC,aAAe,CACpBvB,YAAa,YAAE,UACf/C,YAAa,YAAE,gBACf6C,gBAAgB,EAChBC,eAAgB,UAChBL,UAAW,eACXtC,gBAAgB,EAChB8B,WAAW,EACXL,YAAY,GAyJhB,EAnMA,CAAkC,IAAMZ,WAAnB,MAqMrB,I,IAAMoC,EAAe,YAAO,MAAV,qBAAG,CAAa,8MAAwB,mLA0BvD,UAjBC,SAAAmB,GACA,OAACA,EAAE3C,YACH,OACA,IAAK,4SAiBH0B,EAAiB,YAAO,MAAV,qBAAG,CAAa,sKAEd,8EAAR,YAAM,K,8GCvQpB,aAiDE,WAAY,sBAAC,IAAAlD,EAAA,EAAAA,YAAa,iCA7C1B,KAAAoE,OAA4C,IAAWC,MAO3C,KAAAC,OAAS,IAAIC,IAQb,KAAAC,WAAa,IAAID,IAW7B,KAAAE,gBAAkB,IAAIF,IAKtB,KAAAG,UAA6B,GAM7B,KAAA1E,YAAc,GASZZ,KAAKuF,QAAUA,GAAW,GACtB3E,GACFZ,KAAK0C,eAAe9B,GAGtBZ,KAAKd,IAAM,IAAI,IAinBnB,OA3mBE,YAAA6D,MAAA,WACE/C,KAAKd,KAAOc,KAAKd,IAAIsG,QACrBxF,KAAKd,IAAM,KACXc,KAAKqF,gBAAgBG,QACrBxF,KAAKyF,aAGP,YAAAA,UAAA,WACEzF,KAAKgF,OAAOQ,QACZxF,KAAKkF,OAAOM,QACZxF,KAAKoF,WAAWI,QAChBxF,KAAKsF,UAAY,GACjBtF,KAAKY,YAAc,IAOrB,sBAAI,0BAAW,C,IAAf,WACE,OAAQ,IAAQZ,KAAKY,YAAaZ,KAAKgF,OAAOU,W,gCAIhD,sBAAI,uBAAQ,C,IAAZ,WACE,OAAO1F,KAAKgF,Q,gCAKd,sBAAI,uBAAQ,C,IAAZ,WACE,OAAOhF,KAAK2F,YAAc,IAAUC,Q,gCAKtC,sBAAI,sBAAO,C,IAAX,WACE,QAAS5F,KAAKkF,OAAOW,M,gCAQvB,YAAAnD,eAAA,SAAe9B,GACbZ,KAAKgF,OAAOc,QAAQlF,GAAe,IACnCZ,KAAKY,YAAcZ,KAAKgF,OAAOU,UAAY,GAE3C1F,KAAKsF,UAAY,CAAC,IAAIH,IAAInF,KAAKgF,OAAOe,aAMxC,YAAApD,eAAA,SAAe4C,GACbvF,KAAKuF,QAAUA,GAAW,IAM5B,YAAAS,mBAAA,SAAmBC,EAAYhH,GAE7Be,KAAKqF,gBAAgBa,IAAID,EAAIhH,QAMG,IAAvBA,EAAMkH,mBACmB,IAAzBnG,KAAKY,YAAYqF,KAExBjG,KAAKY,YAAYqF,GACe,mBAAvBhH,EAAMkH,aACTlH,EAAMkH,eACNlH,EAAMkH,aAEZnG,KAAKgF,OAAOkB,IAAID,EAAIjG,KAAKY,YAAYqF,KAGT,mBAAnBhH,EAAMmH,WACfpG,KAAKY,YAAYqF,GAAMhH,EAAMmH,SAASpG,KAAKY,YAAYqF,GAAKhH,GAC5De,KAAKgF,OAAOkB,IAAID,EAAIjG,KAAKY,YAAYqF,MAOzC,YAAAI,YAAA,SAAYJ,GACVjG,KAAKqF,gBAAL,OAA4BY,GAC5BjG,KAAKkF,OAAL,OAAmBe,IAOrB,YAAAK,eAAA,sBACQC,EAAW,IAAIpB,IAAInF,KAAKgF,OAAOe,WACrC,OAAO,WAAM,SAAKT,UAAUkB,QAAf,KAGf,YAAAC,cAAA,SAAcR,EAAYS,GAExB,IAAMC,EAAa3G,KAAKqF,gBAAgBuB,IAAIX,IAAOjG,KAAKqF,gBAAgBwB,IAAIZ,GAC5E,OAAKU,EAIEA,EAAWD,GAHT,MAMX,YAAAI,cAAA,SAAcb,EAAYS,GAExB,IAAMtB,EAAapF,KAAKoF,WAAWwB,IAAIX,IAAOjG,KAAKoF,WAAWyB,IAAIZ,GAClE,OAAKb,EAIEA,EAAWsB,GAHT,MAMX,YAAAK,SAAA,SAASd,GACP,OAAKjG,KAAKgF,OAAO4B,IAAIX,GAIdjG,KAAKgF,OAAO6B,IAAIZ,GAHd,IAMX,YAAAe,oBAAA,SAAoBf,GAClB,IAAMZ,EAAkBrF,KAAKqF,gBAAgBwB,IAAIZ,GAC3CgB,EACJ5B,GAAuD,mBAA7BA,EAAgB0B,SACtC1B,EAAgB0B,SAChB,KACAG,EAAQlH,KAAK+G,SAASd,GAE5B,OAAOgB,EAAcA,EAAYC,GAASA,GAM5C,YAAApF,QAAA,WACE,OAAO9B,KAAKgF,OAAOU,UAMrB,YAAAyB,mBAAA,sBACQtE,EAAO7C,KAAK8B,UAElB,OAAOsF,OAAOC,KAAKxE,GAChBoC,KAAI,SAAAgB,GAAM,OAACA,EAAI,EAAKe,oBAAV,OACVM,QAAO,SAACC,EAAK,G,IAAA,mBAACtB,EAAA,KAAIiB,EAAA,KAEjB,OADAK,EAAItB,GAAMiB,EACHK,IACN,KAGP,YAAAC,SAAA,SAASvB,GACP,OAAOjG,KAAKkF,OAAO0B,IAAIX,IAAOjG,KAAKkF,OAAO2B,IAAIZ,IAIhD,YAAAwB,qBAAA,SAAqBxB,GAEnB,IAAMpB,EAAa7E,KAAKyG,cAAcR,EAAI,YACpCiB,EAAQlH,KAAK+G,SAASd,GAC5B,OAAQpB,GAAyB,KAAVqC,GAAgB,YAAQA,IAGjD,YAAAQ,aAAA,SAAazB,GACX,OAA4C,KAApCjG,KAAKwH,SAASvB,IAAO,IAAI0B,QAGnC,YAAAC,aAAA,SAAa,GAAb,WACEvF,EAAA,EAAAA,YACAC,EAAA,EAAAA,UACA5D,EAAA,EAAAA,KAMMmJ,EAAWxF,GAAerC,KAAKuF,QAAQlD,aAAe,GACtDyF,EAASxF,GAAatC,KAAKuF,QAAQjD,UAEzC,OAAO,IAAIyF,SAAQ,SAACC,EAASC,GAE3B,OAAK,EAAK/I,IAGH,EAAKA,IAAIgJ,QAAQL,EAAU,CAChCC,OAAM,EACNpJ,KAAI,EACJyJ,QAAS,SAAAC,GAAY,OAAAJ,EAAA,IACrB9F,MAAO,YAAS,OAAA+F,EAAA,MANTA,EAAO,IAAII,MAAM,oBAY9B,YAAAjC,SAAA,SAASH,EAAYiB,GACnB,IAAM7B,EAAkBrF,KAAKqF,gBAAgBwB,IAAIZ,GAC7CqC,EAAapB,EAEb7B,GAA6D,mBAAnCA,EAAgBkD,iBAC5CD,EAAajD,EAAgBkD,eAAerB,IAG9ClH,KAAKgF,OAAOkB,IAAID,EAAIqC,GAEhBtI,KAAKuF,QAAQ/C,eACfxC,KAAKuF,QAAQ/C,cAAcyD,EAAIqC,GAGjCtI,KAAKwI,cAAcvC,GACnBjG,KAAKyI,oBAAoBxC,EAAIqC,GAC7BtI,KAAK0I,4BAA4BzC,EAAIqC,IAIvC,YAAAE,cAAA,SAAcvC,GADd,WAEQ0C,EAAW3I,KAAKyG,cAAcR,EAAI,YACpCf,EAAgB,GAEI,mBAAbyD,IAETzD,EAASyD,EAAS,CAAC7J,MAAOkB,KAAMiG,GAAE,EAAEpD,KAAM7C,KAAK8B,aAAe,IAGhE,IAAM8G,EAAyB,YAAE,qBAE5B5I,KAAKyH,qBAAqBxB,IAC7Bf,EAAOrF,KAAK,CAACoG,EAAI2C,KAInB1D,EAA2B,IAAlBA,EAAOyC,OAAe,CAAC,CAAC1B,EAAI,OAASf,GAEvC2D,SAAQ,SAAC,G,IAAA,mBAACC,EAAA,KAAOC,EAAA,KAAkB,SAAKC,SAASF,EAAOC,OAKjE,YAAAN,oBAAA,SAAoBxC,EAAYiB,GAC9B,IAAM+B,EAAiB/B,IAAUlH,KAAKY,YAAYqF,GAG5CiD,EAA0BlJ,KAAKyG,cAAcR,EAAI,mBAChB,IAA5BiD,GAA2CA,GAGlDlJ,KAAK8G,cAAcb,EAAI,cAAgBgD,GAI3CjJ,KAAKmJ,cAAclD,EAAI,WAAYgD,IAIrC,YAAAP,4BAAA,SAA4BzC,EAAYiB,GACtC,IAAM+B,EAAiB/B,IAAUlH,KAAKY,YAAYqF,GACnBjG,KAAKyG,cAAcR,EAAI,qBAMlDjG,KAAK8G,cAAcb,EAAI,sBAAwBgD,GAInDjJ,KAAKmJ,cAAclD,EAAI,mBAAoBgD,IAO7C,YAAAG,KAAA,WAEE,OAAIpJ,KAAKsF,UAAUqC,OAAS,EACnB,MAGT3H,KAAKsF,UAAU+D,QACfrJ,KAAKgF,OAAOc,QAAQ9F,KAAKsF,UAAU,KAE5B,IAOT,YAAAtD,SAAA,WADA,WAEE,IAAKhC,KAAKsJ,eACR,OAAO,KAGT,IAAIC,EAA6BvJ,KAAKsG,iBAEhC4B,EAAUlI,KAAK4H,aAAa,CAChClJ,KAAMsB,KAAKmH,uBA4Bb,OAzBAnH,KAAKX,gBACL6I,EACGsB,MAAK,SAAAC,GAEAF,IACFA,IACAA,EAAe,MAGb,EAAKhE,QAAQ7E,iBACf,EAAK6E,QAAQ7E,gBAAgB+I,EAAM,MATzC,OAYS,SAAAA,GAELF,EAAe,KACX,EAAKhE,QAAQhD,cACf,EAAKG,eAAe,IAEtB,EAAKP,YAAYsH,GACb,EAAKlE,QAAQxD,eACf,EAAKwD,QAAQxD,cAAc0H,EAAM,MAIhCvB,GAST,YAAAwB,UAAA,SAAUzD,EAAY0D,GADtB,WAEQC,EAAW5J,KAAKY,YAAYqF,GAC5B4D,EAAc7J,KAAK8J,iBAAiB7D,EAAI0D,GAE9C,OAAKE,EAIEA,EACJL,MAAK,SAAAC,GACJ,IAAMM,EAAW,EAAKhD,SAASd,GACzB+D,EAAS,CAACC,IAAKL,EAAUM,IAAKH,GAWpC,YARsC,IAA3B,EAAKxE,QAAQ9C,WAA6B,EAAK8C,QAAQ9C,YAChE,YAAsBuH,EAAQ,EAAM/D,GAGlC,EAAKV,QAAQ7E,iBACf,EAAK6E,QAAQ7E,gBAAgB+I,EAAM,EAAMxD,EAAI+D,GAGxCP,KAdJ,OAgBE,SAAAvH,GAIL,OAHI,EAAKqD,QAAQxD,eACf,EAAKwD,QAAQxD,cAAcG,EAAO,EAAM+D,GAEnC,MAvBF,MAqCX,YAAA6D,iBAAA,SAAiB7D,EAAY0D,G,MAD7B,OAEQQ,EAAenK,KAAKY,YAAYqF,GAItC,GACE0D,IAAiBQ,GACC,KAAjBR,IAAwB,YAAQQ,GAEjC,OAAO,KAKT,GADAnK,KAAKwI,cAAcvC,IACdjG,KAAK0H,aAAazB,GACrB,OAAO,KAIT,IAAIsD,EAA6BvJ,KAAKsG,iBAGtCtG,KAAKoK,UAAUnE,GAAI,GAEnB,IAAMZ,EAAkBrF,KAAKqF,gBAAgBwB,IAAIZ,GAG3CnE,EAC+B,mBAA5BuD,EAAgBvD,QAAyBuD,EAAgBvD,QAAU,SAAA/C,GAAK,OAAAA,GAE3EmJ,EAAUlI,KAAK4H,aAAa,CAChClJ,KAAMoD,GAAO,KACV,EAACmE,GAAKjG,KAAKgH,oBAAoBf,GAAG,GACnC,CAACnH,MAAOkB,KAAMiG,GAAE,EAAEpD,KAAM7C,KAAK8B,cAyDjC,OArDAoG,EACGsB,MAAK,SAAA9K,GAYJ,OAXA,EAAK0L,UAAUnE,GAAI,GAGfsD,IACFA,IACAA,EAAe,MAIjB,EAAK3I,YAAYqF,GAAM,EAAKc,SAASd,GAE9BvH,KAbX,OAeS,SAAA+K,GAELF,EAAe,KAIK,EAAK9C,cAAcR,EAAI,iBAEzC,EAAKG,SAASH,EAAIkE,GAMhBV,GAAQA,EAAKY,aAEXC,MAAMC,QAAQd,EAAKY,aAAapE,KAAQwD,EAAKY,aAAapE,GAAI0B,OAEhE,EAAKqB,SAAS/C,EAAIwD,EAAKY,aAAapE,GAAI,IAExCqE,MAAMC,QAAQd,EAAKY,aAAaG,mBAChCf,EAAKY,aAAaG,iBAAiB7C,QAEnC,YAAgB8B,EAAKY,aAAaG,iBAAiB,GAAI,KAEvD,EAAKxB,SAAS/C,EAAI,KAElB,EAAK+C,SAAS/C,EAAI,kBAIpB,EAAK+C,SAAS/C,EAAI,kBAIpBwE,QAAQvI,MAAM,0BAA2BuH,GAAQA,EAAKY,iBAGnDnC,GAST,YAAAwC,gBAAA,SAAgBzE,EAAY0D,GAE1B,IAAK3J,KAAKuF,QAAQnD,WAChB,OAAO,KAIT,IAAM8G,EAA0BlJ,KAAKyG,cAAcR,EAAI,cACvD,YAAuC,IAA5BiD,GAA4CA,EAIhDlJ,KAAK0J,UAAUzD,EAAI0D,GAHjB,MAOX,YAAAtK,cAAA,WACEW,KAAK2F,UAAY,IAAUC,QAO7B,YAAA+E,gBAAA,SAAgB1E,EAAY0D,GAD5B,WAEQE,EAAc7J,KAAK0J,UAAUzD,EAAI0D,GAEvC,OAAKE,EAIEA,EAAYL,MAAK,WACtB,EAAKL,cAAclD,EAAI,YAAY,MAJ5B,MAYX,YAAA2E,sBAAA,SAAsB3E,GACpBjG,KAAKoG,SAASH,EAAIjG,KAAKY,YAAYqF,IACnCjG,KAAKmJ,cAAclD,EAAI,YAAY,IAIrC,YAAAkD,cAAA,SAAclD,EAAYS,EAAaQ,G,MAC/B2D,EAAQ,OAAH,IAAG,CAAH,eACL7K,KAAKoF,WAAWyB,IAAIZ,IAAO,MAAG,MACjCS,GAAMQ,EAAK,IAEdlH,KAAKoF,WAAWc,IAAID,EAAI4E,IAO1B,YAAAT,UAAA,SAAUnE,EAAYiB,GAEpBlH,KAAKgJ,SAAS/C,GAAI,GAClBjG,KAAKmJ,cAAclD,EAAI,IAAUL,OAAQsB,GACzClH,KAAKmJ,cAAclD,EAAI,IAAU6E,OAAQ5D,IAO3C,YAAA8B,SAAA,SAAS/C,EAAY/D,GAGbA,GACJlC,KAAK2F,UAAY,IAAUoF,MAC3B/K,KAAKkF,OAAOgB,IAAID,EAAI/D,KAEpBlC,KAAK2F,UAAY,IAAUmF,MAC3B9K,KAAKkF,OAAL,OAAmBe,IAIrBjG,KAAKmJ,cAAclD,EAAI,IAAUL,QAAQ,IAO3C,YAAA0D,aAAA,WADA,WAIE,OAFAgB,MAAMU,KAAKhL,KAAKqF,gBAAgBgC,QAAQwB,SAAQ,SAAA5C,GAAM,OAAC,EAAKuC,cAAN,OAE9CxI,KAAKoE,SAIf,YAAA6G,oBAAA,SAAoB,GADpB,WACqBxB,QAAA,YAAAY,aACdZ,GAKLrC,OAAOC,KAAKoC,GAAMZ,SAAQ,SAAA5C,GAEf,qBAAPA,GACAqE,MAAMC,QAAQd,EAAKe,mBACnBf,EAAKe,iBAAiB7C,OAEtB,YAAgB8B,EAAKe,iBAAiB,GAAI,KACjCF,MAAMC,QAAQd,EAAKxD,KAAQwD,EAAKxD,GAAI0B,QAE7C,EAAKqB,SAAS/C,EAAIwD,EAAKxD,GAAI,QAMjC,YAAAhE,cAAA,SAAcvD,GAEZsB,KAAK2F,UAAY,IAAUmF,MAC3B9K,KAAKY,YAAclC,GAIrB,YAAAyD,YAAA,SAAY+I,GACVlL,KAAK2F,UAAY,IAAUoF,MAC3B/K,KAAKmL,WAAanL,KAAKoL,cAAcF,EAAIb,cACzCrK,KAAKiL,oBAAoB,CAACZ,aAAcrK,KAAKmL,cAG/C,YAAAC,cAAA,SAAcf,GACZ,OAAOA,GA3pBG,aAAX,K,6BAQW,aAAX,K,iCAKW,aAAX,K,gCAwDD,aADC,K,0BAGA,MAGD,aADC,K,uBAGA,MAID,aADC,K,uBAGA,MAID,aADC,K,sBAGA,MAyKD,aADC,K,uBAkBA,MAGD,aADC,K,4BAqBA,MAGD,aADC,K,kCAcA,MAGD,aADC,K,0CAcA,MAMD,aADC,K,mBAWA,MAMD,aADC,K,uBAsCA,MAQD,aADC,K,wBA+BA,MAYD,aADC,K,+BA4FA,MAQD,aADC,K,8BAcA,MAGD,aADC,K,4BAGA,MAMD,aADC,K,8BAWA,MAMD,aADC,K,oCAIA,MAGD,aADC,K,4BAOA,MAMD,aADC,K,wBAMA,MAMD,aADC,K,uBAcA,MAMD,aADC,K,2BAKA,MAGD,aADC,K,kCAmBA,MAGD,aADC,K,4BAKA,MAGD,aADC,K,0BAKA,MAKH,EAxqBA,GA0qBe,O,mMCvsBMgB,E,yIAMjB,OAAO,kBAAC,IAAD,OAAgBrL,KAAKf,MAArB,CAA4B8E,KAAK,c,GANLxC,IAAMC,WAAxB6J,E,2SCYd,SAAe/L,EAAeJ,EAAKC,EAAcI,EAAO+L,GAAxD,eAAAvM,EAAAC,OAAA,uDACLuM,YAAkBjL,YAAE,6BADf,oBAAAvB,EAAA,MAIgBG,EAAIsM,eAAJ,yBACCrM,EAAaW,KADd,eAEjB,CACEgI,OAAQ,OACRpJ,KAAM,CACJa,QACA+L,SACAG,MAAO,OAXV,cAIGhC,EAJH,OAeHiC,cAfG,kBAgBIjC,GAhBJ,sCAkBHkC,YAAgBrL,YAAE,8BAlBf,6DA0BA,SAAesL,EAAwB1M,EAAK2M,EAAOC,GAAnD,SAAA/M,EAAAC,OAAA,yEACEE,EAAIsM,eAAJ,yBAAqCK,EAArC,sBAAwDC,EAAxD,gBADF,qCAOA,SAAeC,EAAmB7M,EAAK2M,EAAOC,EAAYE,GAA1D,eAAAjN,EAAAC,OAAA,2EAAAD,EAAA,MAEkBG,EAAIsM,eAAJ,yBACDK,EADC,sBACkBC,EADlB,cAEnB,CACEhE,OAAQ,OACRpJ,KAAM,CACJuN,SAAUD,EAAKC,SACfC,QAASF,EAAKG,SARjB,cAEGC,EAFH,yBAaIA,GAbJ,sCAeHT,YAAgBrL,YAAE,2BAff,6DAuBA,SAAe+L,EAAmBnN,EAAK2M,EAAOC,EAAYQ,GAA1D,eAAAvN,EAAAC,OAAA,2EAAAD,EAAA,MAEkBG,EAAIsM,eAAJ,yBACDK,EADC,sBACkBC,EADlB,qBACyCQ,EADzC,KAEnB,CACExE,OAAQ,YALT,cAEGsE,EAFH,yBASIA,GATJ,sCAWHT,YAAgBrL,YAAE,6BAXf,6DAmBA,SAAeiM,EAAmBrN,EAAK2M,EAAOC,EAAYQ,EAAQN,GAAlE,eAAAjN,EAAAC,OAAA,2EAAAD,EAAA,MAEkBG,EAAIsM,eAAJ,yBACDK,EADC,sBACkBC,EADlB,qBACyCQ,EADzC,KAEnB,CACExE,OAAQ,MACRpJ,KAAM,CACJuN,SAAUD,EAAKC,SACfC,QAASF,EAAKG,SARjB,cAEGC,EAFH,OAYHV,cAZG,kBAaIU,GAbJ,sCAeHT,YAAgBrL,YAAE,6BAff,6DAsBA,SAAekM,EAAmBtN,EAAK2M,EAAOrM,GAA9C,SAAAT,EAAAC,OAAA,mDACAQ,IAAYA,EAASiN,QADrB,4EAAA1N,EAAA,MAMGG,EAAIsM,eAAJ,yBACcK,EADd,sBACiCrM,EAASO,WAD1C,UAEJ,CACE+H,OAAQ,OACRpJ,KAAM,CACJ+N,SAAS,MAXZ","file":"CreateIncidentModal.js","sourcesContent":["import {browserHistory} from 'react-router';\nimport PropTypes from 'prop-types';\nimport React from 'react';\n\nimport {createIncident} from 'app/actionCreators/incident';\nimport {t} from 'app/locale';\nimport Form from 'app/views/settings/components/forms/form';\nimport SentryTypes from 'app/sentryTypes';\nimport TextField from 'app/views/settings/components/forms/textField';\nimport withApi from 'app/utils/withApi';\n\nclass CreateIncidentModal extends React.Component {\n  static propTypes = {\n    api: PropTypes.object.isRequired,\n    issues: PropTypes.arrayOf(PropTypes.string),\n    closeModal: PropTypes.func,\n    onClose: PropTypes.func,\n    Body: PropTypes.oneOfType([PropTypes.func, PropTypes.node]).isRequired,\n    Header: PropTypes.oneOfType([PropTypes.func, PropTypes.node]).isRequired,\n    organization: SentryTypes.Organization.isRequired,\n  };\n\n  handleSubmit = async (data, onSuccess, onError, _e, model) => {\n    const {api, organization, issues} = this.props;\n\n    model.setFormSaving();\n\n    try {\n      const incident = await createIncident(api, organization, data.title, issues);\n      onSuccess(incident);\n    } catch (err) {\n      onError(err);\n    }\n  };\n\n  handleSuccess = data => {\n    const {organization, onClose, closeModal} = this.props;\n\n    if (onClose) {\n      onClose(data);\n    }\n\n    closeModal();\n\n    if (data) {\n      browserHistory.push(\n        `/organizations/${organization.slug}/incidents/${data.identifier}/`\n      );\n    }\n  };\n\n  render() {\n    const {Body, Header, closeModal} = this.props;\n\n    return (\n      <React.Fragment>\n        <Header closeButton onHide={closeModal}>\n          {t('Create New Incident')}\n        </Header>\n        <Body>\n          <Form\n            data-test-id=\"create-new-incident-form\"\n            submitLabel={t('Create Incident')}\n            onSubmit={this.handleSubmit}\n            onSubmitSuccess={this.handleSuccess}\n            requireChanges\n            initialData={{\n              date: new Date(),\n            }}\n          >\n            <TextField\n              name=\"title\"\n              label={t('Incident Name')}\n              placeholder={t('Incident Name')}\n              help={t('Give a name to help identify the incident')}\n              required\n              stacked\n              inline={false}\n              flexibleControlStateSize\n            />\n          </Form>\n        </Body>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default withApi(CreateIncidentModal);\n","import {Observer} from 'mobx-react';\nimport PropTypes from 'prop-types';\nimport React from 'react';\nimport styled from 'react-emotion';\n\nimport {APIRequestMethod} from 'app/api';\nimport {t} from 'app/locale';\nimport Button from 'app/components/button';\nimport FormModel, {\n  FormOptions,\n  FieldValue,\n} from 'app/views/settings/components/forms/model';\nimport Panel from 'app/components/panels/panel';\nimport space from 'app/styles/space';\n\ntype Data = {};\n\ntype RenderProps = {\n  model: FormModel;\n};\n\ntype RenderFunc = (props: RenderProps) => React.ReactNode;\n\n// Type guard for render func.\nfunction isRenderFunc(func: React.ReactNode | Function): func is RenderFunc {\n  return typeof func === 'function';\n}\n\ntype Props = {\n  apiMethod?: APIRequestMethod;\n  apiEndpoint?: string;\n  children: React.ReactNode | RenderFunc;\n  className?: string;\n  cancelLabel?: string;\n  submitDisabled?: boolean;\n  submitLabel?: string;\n  submitPriority?: Button['props']['priority'];\n  footerClass?: string;\n  footerStyle?: React.CSSProperties;\n  extraButton?: React.ReactNode;\n  initialData?: Data;\n  // Require changes before able to submit form\n  requireChanges?: boolean;\n  // Reset form when there are errors; after submit\n  resetOnError?: boolean;\n  hideFooter?: boolean;\n  allowUndo?: boolean;\n  // Save field on control blur\n  saveOnBlur?: boolean;\n  model?: FormModel;\n  'data-test-id'?: string;\n\n  onCancel?: (e: React.MouseEvent) => void;\n  onSubmit?: (\n    data: Data,\n    onSubmitSuccess: (data: Data) => void,\n    onSubmitError: (error: any) => void,\n    e: React.FormEvent,\n    model: FormModel\n  ) => void;\n} & Pick<FormOptions, 'onSubmitSuccess' | 'onSubmitError' | 'onFieldChange'>;\n\ntype Context = {\n  saveOnBlur: boolean;\n  form: FormModel;\n};\n\nexport default class Form extends React.Component<Props> {\n  static propTypes: any = {\n    cancelLabel: PropTypes.string,\n    onCancel: PropTypes.func,\n    onSubmit: PropTypes.func,\n    onSubmitSuccess: PropTypes.func,\n    onSubmitError: PropTypes.func,\n    onFieldChange: PropTypes.func,\n    submitDisabled: PropTypes.bool,\n    submitLabel: PropTypes.string,\n    submitPriority: PropTypes.string,\n    footerClass: PropTypes.string,\n    footerStyle: PropTypes.object,\n    extraButton: PropTypes.element,\n    initialData: PropTypes.object,\n    // Require changes before able to submit form\n    requireChanges: PropTypes.bool,\n    // Reset form when there are errors, after submit\n    resetOnError: PropTypes.bool,\n    hideFooter: PropTypes.bool,\n    allowUndo: PropTypes.bool,\n    // Save field on control blur\n    saveOnBlur: PropTypes.bool,\n    model: PropTypes.object,\n    apiMethod: PropTypes.string,\n    apiEndpoint: PropTypes.string,\n    'data-test-id': PropTypes.string,\n  };\n\n  static childContextTypes = {\n    saveOnBlur: PropTypes.bool.isRequired,\n    form: PropTypes.object.isRequired,\n  };\n\n  static defaultProps = {\n    cancelLabel: t('Cancel'),\n    submitLabel: t('Save Changes'),\n    submitDisabled: false,\n    submitPriority: 'primary' as 'primary',\n    className: 'form-stacked',\n    requireChanges: false,\n    allowUndo: false,\n    saveOnBlur: false,\n  };\n\n  constructor(props: Props, context: Context) {\n    super(props, context);\n    const {\n      saveOnBlur,\n      apiEndpoint,\n      apiMethod,\n      resetOnError,\n      onSubmitSuccess,\n      onSubmitError,\n      onFieldChange,\n      initialData,\n      allowUndo,\n    } = props;\n\n    this.model.setInitialData(initialData);\n    this.model.setFormOptions({\n      resetOnError,\n      allowUndo,\n      onFieldChange,\n      onSubmitSuccess,\n      onSubmitError,\n      saveOnBlur,\n      apiEndpoint,\n      apiMethod,\n    });\n  }\n\n  getChildContext() {\n    return {\n      saveOnBlur: this.props.saveOnBlur,\n      form: this.model,\n    };\n  }\n\n  componentWillUnmount() {\n    this.model.reset();\n  }\n\n  model: FormModel = this.props.model || new FormModel();\n\n  onSubmit = e => {\n    e.preventDefault();\n    if (this.model.isSaving) {\n      return;\n    }\n\n    if (this.props.onSubmit) {\n      this.props.onSubmit(\n        this.model.getData(),\n        this.onSubmitSuccess,\n        this.onSubmitError,\n        e,\n        this.model\n      );\n    } else {\n      this.model.saveForm();\n    }\n  };\n\n  onSubmitSuccess = data => {\n    const {onSubmitSuccess} = this.props;\n    this.model.submitSuccess(data);\n\n    if (onSubmitSuccess) {\n      onSubmitSuccess(data, this.model);\n    }\n  };\n\n  onSubmitError = error => {\n    const {onSubmitError} = this.props;\n    this.model.submitError(error);\n\n    if (onSubmitError) {\n      onSubmitError(error, this.model);\n    }\n  };\n\n  render() {\n    const {\n      className,\n      children,\n      footerClass,\n      footerStyle,\n      submitDisabled,\n      submitLabel,\n      submitPriority,\n      cancelLabel,\n      onCancel,\n      extraButton,\n      requireChanges,\n      saveOnBlur,\n      hideFooter,\n    } = this.props;\n    const shouldShowFooter =\n      typeof hideFooter !== 'undefined' ? !hideFooter : !saveOnBlur;\n\n    return (\n      <form\n        onSubmit={this.onSubmit}\n        className={className}\n        data-test-id={this.props['data-test-id']}\n      >\n        <div>{isRenderFunc(children) ? children({model: this.model}) : children}</div>\n\n        {shouldShowFooter && (\n          <StyledFooter\n            className={footerClass}\n            style={footerStyle}\n            saveOnBlur={saveOnBlur}\n          >\n            {extraButton}\n            <DefaultButtons>\n              {onCancel && (\n                <Observer>\n                  {() => (\n                    <Button\n                      type=\"button\"\n                      disabled={this.model.isSaving}\n                      onClick={onCancel}\n                      style={{marginLeft: 5}}\n                    >\n                      {cancelLabel}\n                    </Button>\n                  )}\n                </Observer>\n              )}\n\n              <Observer>\n                {() => (\n                  <Button\n                    data-test-id=\"form-submit\"\n                    priority={submitPriority}\n                    disabled={\n                      this.model.isError ||\n                      this.model.isSaving ||\n                      submitDisabled ||\n                      (requireChanges ? !this.model.formChanged : false)\n                    }\n                    type=\"submit\"\n                  >\n                    {submitLabel}\n                  </Button>\n                )}\n              </Observer>\n            </DefaultButtons>\n          </StyledFooter>\n        )}\n      </form>\n    );\n  }\n}\n\nconst StyledFooter = styled('div')<{saveOnBlur?: boolean}>`\n  display: flex;\n  justify-content: flex-end;\n  margin-top: 25px;\n  border-top: 1px solid #e9ebec;\n  background: none;\n  padding: 16px 0 0;\n  margin-bottom: 16px;\n\n  ${p =>\n    !p.saveOnBlur &&\n    `\n  ${Panel} & {\n    margin-top: 0;\n    padding-right: 36px;\n  }\n\n  /* Better padding with form inside of a modal */\n  .modal-content & {\n    padding-right: 30px;\n    margin-left: -30px;\n    margin-right: -30px;\n    margin-bottom: -30px;\n    margin-top: 16px;\n    padding-bottom: 16px;\n  }\n  `};\n`;\n\nconst DefaultButtons = styled('div')`\n  display: grid;\n  grid-gap: ${space(1)};\n  grid-auto-flow: column;\n  justify-content: flex-end;\n  flex: 1;\n`;\n\nexport {FieldValue};\n","import {observable, computed, action, ObservableMap} from 'mobx';\nimport isEqual from 'lodash/isEqual';\n\nimport {Client, APIRequestMethod} from 'app/api';\nimport {addErrorMessage, saveOnBlurUndoMessage} from 'app/actionCreators/indicator';\nimport {defined} from 'app/utils';\nimport {t} from 'app/locale';\nimport FormState from 'app/components/forms/state';\n\ntype Snapshot = Map<string, FieldValue>;\ntype SaveSnapshot = (() => number) | null;\n\nexport type FieldValue = string | number | boolean | undefined; //is undefined valid here?\n\nexport type FormOptions = {\n  apiEndpoint?: string;\n  apiMethod?: APIRequestMethod;\n  allowUndo?: boolean;\n  resetOnError?: boolean;\n  saveOnBlur?: boolean;\n  onFieldChange?: (id: string, finalValue: FieldValue) => void;\n  onSubmitSuccess?: (\n    response: any,\n    instance: FormModel,\n    id?: string,\n    change?: {old: FieldValue; new: FieldValue}\n  ) => void;\n  onSubmitError?: (error: any, instance: FormModel, id?: string) => void;\n};\n\ntype OptionsWithInitial = FormOptions & {initialData?: object};\n\nclass FormModel {\n  /**\n   * Map of field name -> value\n   */\n  fields: ObservableMap<string, FieldValue> = observable.map();\n\n  /**\n   * Errors for individual fields\n   * Note we don't keep error in `this.fieldState` so that we can easily\n   * See if the form is in an \"error\" state with the `isError` getter\n   */\n  @observable errors = new Map();\n\n  /**\n   * State of individual fields\n   *\n   * Map of field name -> object\n   */\n\n  @observable fieldState = new Map();\n\n  /**\n   * State of the form as a whole\n   */\n  @observable formState;\n\n  /**\n   * Holds field properties as declared in <Form>\n   * Does not need to be observable since these props should never change\n   */\n  fieldDescriptor = new Map();\n\n  /**\n   * Holds a list of `fields` states\n   */\n  snapshots: Array<Snapshot> = [];\n\n  /**\n   * POJO of field name -> value\n   * It holds field values \"since last save\"\n   */\n  initialData = {};\n\n  api: Client | null;\n\n  formErrors: any;\n\n  options: FormOptions;\n\n  constructor({initialData, ...options}: OptionsWithInitial = {}) {\n    this.options = options || {};\n    if (initialData) {\n      this.setInitialData(initialData);\n    }\n\n    this.api = new Client();\n  }\n\n  /**\n   * Reset state of model\n   */\n  reset() {\n    this.api && this.api.clear();\n    this.api = null;\n    this.fieldDescriptor.clear();\n    this.resetForm();\n  }\n\n  resetForm() {\n    this.fields.clear();\n    this.errors.clear();\n    this.fieldState.clear();\n    this.snapshots = [];\n    this.initialData = {};\n  }\n\n  /**\n   * Deep equality comparison between last saved state and current fields state\n   */\n  @computed\n  get formChanged() {\n    return !isEqual(this.initialData, this.fields.toJSON());\n  }\n\n  @computed\n  get formData() {\n    return this.fields;\n  }\n\n  /** Is form saving */\n  @computed\n  get isSaving() {\n    return this.formState === FormState.SAVING;\n  }\n\n  /** Does form have any errors */\n  @computed\n  get isError() {\n    return !!this.errors.size;\n  }\n\n  /**\n   * Sets initial form data\n   *\n   * Also resets snapshots\n   */\n  setInitialData(initialData?: object) {\n    this.fields.replace(initialData || {});\n    this.initialData = this.fields.toJSON() || {};\n\n    this.snapshots = [new Map(this.fields.entries())];\n  }\n\n  /**\n   * Set form options\n   */\n  setFormOptions(options: FormOptions) {\n    this.options = options || {};\n  }\n\n  /**\n   * Set field properties\n   */\n  setFieldDescriptor(id: string, props) {\n    //TODO(TS): add type to props\n    this.fieldDescriptor.set(id, props);\n\n    // Set default value iff initialData for field is undefined\n    // This must take place before checking for `props.setValue` so that it can\n    // be applied to `defaultValue`\n    if (\n      typeof props.defaultValue !== 'undefined' &&\n      typeof this.initialData[id] === 'undefined'\n    ) {\n      this.initialData[id] =\n        typeof props.defaultValue === 'function'\n          ? props.defaultValue()\n          : props.defaultValue;\n\n      this.fields.set(id, this.initialData[id]);\n    }\n\n    if (typeof props.setValue === 'function') {\n      this.initialData[id] = props.setValue(this.initialData[id], props);\n      this.fields.set(id, this.initialData[id]);\n    }\n  }\n\n  /**\n   * Remove a field from the descriptor map and errors.\n   */\n  removeField(id: string) {\n    this.fieldDescriptor.delete(id);\n    this.errors.delete(id);\n  }\n\n  /**\n   * Creates a cloned Map of `this.fields` and returns a closure that when called\n   * will save Map to `snapshots\n   */\n  createSnapshot() {\n    const snapshot = new Map(this.fields.entries());\n    return () => this.snapshots.unshift(snapshot);\n  }\n\n  getDescriptor(id: string, key: string) {\n    // Needs to call `has` or else component will not be reactive if `id` doesn't exist in observable map\n    const descriptor = this.fieldDescriptor.has(id) && this.fieldDescriptor.get(id);\n    if (!descriptor) {\n      return null;\n    }\n\n    return descriptor[key];\n  }\n\n  getFieldState(id: string, key: string) {\n    // Needs to call `has` or else component will not be reactive if `id` doesn't exist in observable map\n    const fieldState = this.fieldState.has(id) && this.fieldState.get(id);\n    if (!fieldState) {\n      return null;\n    }\n\n    return fieldState[key];\n  }\n\n  getValue(id: string) {\n    if (!this.fields.has(id)) {\n      return '';\n    }\n\n    return this.fields.get(id);\n  }\n\n  getTransformedValue(id: string) {\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n    const transformer =\n      fieldDescriptor && typeof fieldDescriptor.getValue === 'function'\n        ? fieldDescriptor.getValue\n        : null;\n    const value = this.getValue(id);\n\n    return transformer ? transformer(value) : value;\n  }\n\n  /**\n   * Data represented in UI\n   */\n  getData() {\n    return this.fields.toJSON();\n  }\n\n  /**\n   * Form data that will be sent to API endpoint (i.e. after transforms)\n   */\n  getTransformedData() {\n    const form = this.getData();\n\n    return Object.keys(form)\n      .map(id => [id, this.getTransformedValue(id)])\n      .reduce((acc, [id, value]) => {\n        acc[id] = value;\n        return acc;\n      }, {});\n  }\n\n  getError(id: string) {\n    return this.errors.has(id) && this.errors.get(id);\n  }\n\n  // Returns true if not required or is required and is not empty\n  isValidRequiredField(id: string) {\n    // Check field descriptor to see if field is required\n    const isRequired = this.getDescriptor(id, 'required');\n    const value = this.getValue(id);\n    return !isRequired || (value !== '' && defined(value));\n  }\n\n  isValidField(id: string) {\n    return (this.getError(id) || []).length === 0;\n  }\n\n  doApiRequest({\n    apiEndpoint,\n    apiMethod,\n    data,\n  }: {\n    apiEndpoint?: string;\n    apiMethod?: APIRequestMethod;\n    data: object;\n  }) {\n    const endpoint = apiEndpoint || this.options.apiEndpoint || '';\n    const method = apiMethod || this.options.apiMethod;\n\n    return new Promise((resolve, reject) => {\n      //should never happen but TS complains if we don't check\n      if (!this.api) {\n        return reject(new Error('Api not set'));\n      }\n      return this.api.request(endpoint, {\n        method,\n        data,\n        success: response => resolve(response),\n        error: error => reject(error),\n      });\n    });\n  }\n\n  @action\n  setValue(id: string, value: FieldValue) {\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n    let finalValue = value;\n\n    if (fieldDescriptor && typeof fieldDescriptor.transformInput === 'function') {\n      finalValue = fieldDescriptor.transformInput(value);\n    }\n\n    this.fields.set(id, finalValue);\n\n    if (this.options.onFieldChange) {\n      this.options.onFieldChange(id, finalValue);\n    }\n\n    this.validateField(id);\n    this.updateShowSaveState(id, finalValue);\n    this.updateShowReturnButtonState(id, finalValue);\n  }\n\n  @action\n  validateField(id: string) {\n    const validate = this.getDescriptor(id, 'validate');\n    let errors: any[] = [];\n\n    if (typeof validate === 'function') {\n      // Returns \"tuples\" of [id, error string]\n      errors = validate({model: this, id, form: this.getData()}) || [];\n    }\n\n    const fieldIsRequiredMessage = t('Field is required');\n\n    if (!this.isValidRequiredField(id)) {\n      errors.push([id, fieldIsRequiredMessage]);\n    }\n\n    // If we have no errors, ensure we clear the field\n    errors = errors.length === 0 ? [[id, null]] : errors;\n\n    errors.forEach(([field, errorMessage]) => this.setError(field, errorMessage));\n    return undefined;\n  }\n\n  @action\n  updateShowSaveState(id: string, value: FieldValue) {\n    const isValueChanged = value !== this.initialData[id];\n    // Update field state to \"show save\" if save on blur is disabled for this field\n    // (only if contents of field differs from initial value)\n    const saveOnBlurFieldOverride = this.getDescriptor(id, 'saveOnBlur');\n    if (typeof saveOnBlurFieldOverride === 'undefined' || saveOnBlurFieldOverride) {\n      return;\n    }\n    if (this.getFieldState(id, 'showSave') === isValueChanged) {\n      return;\n    }\n\n    this.setFieldState(id, 'showSave', isValueChanged);\n  }\n\n  @action\n  updateShowReturnButtonState(id: string, value: FieldValue) {\n    const isValueChanged = value !== this.initialData[id];\n    const shouldShowReturnButton = this.getDescriptor(id, 'showReturnButton');\n\n    if (!shouldShowReturnButton) {\n      return;\n    }\n    // Only update state if state has changed\n    if (this.getFieldState(id, 'showReturnButton') === isValueChanged) {\n      return;\n    }\n\n    this.setFieldState(id, 'showReturnButton', isValueChanged);\n  }\n\n  /**\n   * Changes form values to previous saved state\n   */\n  @action\n  undo() {\n    // Always have initial data snapshot\n    if (this.snapshots.length < 2) {\n      return null;\n    }\n\n    this.snapshots.shift();\n    this.fields.replace(this.snapshots[0]);\n\n    return true;\n  }\n\n  /**\n   * Attempts to save entire form to server and saves a snapshot for undos\n   */\n  @action\n  saveForm() {\n    if (!this.validateForm()) {\n      return null;\n    }\n\n    let saveSnapshot: SaveSnapshot = this.createSnapshot();\n\n    const request = this.doApiRequest({\n      data: this.getTransformedData(),\n    });\n\n    this.setFormSaving();\n    request\n      .then(resp => {\n        // save snapshot\n        if (saveSnapshot) {\n          saveSnapshot();\n          saveSnapshot = null;\n        }\n\n        if (this.options.onSubmitSuccess) {\n          this.options.onSubmitSuccess(resp, this);\n        }\n      })\n      .catch(resp => {\n        // should we revert field value to last known state?\n        saveSnapshot = null;\n        if (this.options.resetOnError) {\n          this.setInitialData({});\n        }\n        this.submitError(resp);\n        if (this.options.onSubmitError) {\n          this.options.onSubmitError(resp, this);\n        }\n      });\n\n    return request;\n  }\n\n  /**\n   * Attempts to save field and show undo message if necessary.\n   * Calls submit handlers.\n   * TODO(billy): This should return a promise that resolves (instead of null)\n   */\n  @action\n  saveField(id: string, currentValue: FieldValue) {\n    const oldValue = this.initialData[id];\n    const savePromise = this.saveFieldRequest(id, currentValue);\n\n    if (!savePromise) {\n      return null;\n    }\n\n    return savePromise\n      .then(resp => {\n        const newValue = this.getValue(id);\n        const change = {old: oldValue, new: newValue};\n\n        // Only use `allowUndo` option if explicitly defined\n        if (typeof this.options.allowUndo === 'undefined' || this.options.allowUndo) {\n          saveOnBlurUndoMessage(change, this, id);\n        }\n\n        if (this.options.onSubmitSuccess) {\n          this.options.onSubmitSuccess(resp, this, id, change);\n        }\n\n        return resp;\n      })\n      .catch(error => {\n        if (this.options.onSubmitError) {\n          this.options.onSubmitError(error, this, id);\n        }\n        return {};\n      });\n  }\n\n  /**\n   * Saves a field with new value\n   *\n   * If field has changes, field does not have errors, then it will:\n   * Save a snapshot, apply any data transforms, perform api request.\n   *\n   * If successful then: 1) reset save state, 2) update `initialData`, 3) save snapshot\n   * If failed then: 1) reset save state, 2) add error state\n   */\n  @action\n  saveFieldRequest(id: string, currentValue: FieldValue) {\n    const initialValue = this.initialData[id];\n\n    // Don't save if field hasn't changed\n    // Don't need to check for error state since initialData wouldn't have updated since last error\n    if (\n      currentValue === initialValue ||\n      (currentValue === '' && !defined(initialValue))\n    ) {\n      return null;\n    }\n\n    // Check for error first\n    this.validateField(id);\n    if (!this.isValidField(id)) {\n      return null;\n    }\n\n    // shallow clone fields\n    let saveSnapshot: SaveSnapshot = this.createSnapshot();\n\n    // Save field + value\n    this.setSaving(id, true);\n\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n\n    // Check if field needs to handle transforming request object\n    const getData =\n      typeof fieldDescriptor.getData === 'function' ? fieldDescriptor.getData : a => a;\n\n    const request = this.doApiRequest({\n      data: getData(\n        {[id]: this.getTransformedValue(id)},\n        {model: this, id, form: this.getData()}\n      ),\n    });\n\n    request\n      .then(data => {\n        this.setSaving(id, false);\n\n        // save snapshot\n        if (saveSnapshot) {\n          saveSnapshot();\n          saveSnapshot = null;\n        }\n\n        // Update initialData after successfully saving a field as it will now be the baseline value\n        this.initialData[id] = this.getValue(id);\n\n        return data;\n      })\n      .catch(resp => {\n        // should we revert field value to last known state?\n        saveSnapshot = null;\n\n        // Field can be configured to reset on error\n        // e.g. BooleanFields\n        const shouldReset = this.getDescriptor(id, 'resetOnError');\n        if (shouldReset) {\n          this.setValue(id, initialValue);\n        }\n\n        // API can return a JSON object with either:\n        // 1) map of {[fieldName] => Array<ErrorMessages>}\n        // 2) {'non_field_errors' => Array<ErrorMessages>}\n        if (resp && resp.responseJSON) {\n          // Show resp msg from API endpoint if possible\n          if (Array.isArray(resp.responseJSON[id]) && resp.responseJSON[id].length) {\n            // Just take first resp for now\n            this.setError(id, resp.responseJSON[id][0]);\n          } else if (\n            Array.isArray(resp.responseJSON.non_field_errors) &&\n            resp.responseJSON.non_field_errors.length\n          ) {\n            addErrorMessage(resp.responseJSON.non_field_errors[0], 10000);\n            // Reset saving state\n            this.setError(id, '');\n          } else {\n            this.setError(id, 'Failed to save');\n          }\n        } else {\n          // Default error behavior\n          this.setError(id, 'Failed to save');\n        }\n\n        // eslint-disable-next-line no-console\n        console.error('Error saving form field', resp && resp.responseJSON);\n      });\n\n    return request;\n  }\n\n  /**\n   * This is called when a field is blurred\n   *\n   * If `saveOnBlur` is set then call `saveField` and handle form callbacks accordingly\n   */\n  @action\n  handleBlurField(id: string, currentValue: FieldValue) {\n    // Nothing to do if `saveOnBlur` is not on\n    if (!this.options.saveOnBlur) {\n      return null;\n    }\n\n    // Fields can individually set `saveOnBlur` to `false` (note this is ignored when `undefined`)\n    const saveOnBlurFieldOverride = this.getDescriptor(id, 'saveOnBlur');\n    if (typeof saveOnBlurFieldOverride !== 'undefined' && !saveOnBlurFieldOverride) {\n      return null;\n    }\n\n    return this.saveField(id, currentValue);\n  }\n\n  @action\n  setFormSaving() {\n    this.formState = FormState.SAVING;\n  }\n\n  /**\n   * This is called when a field does not saveOnBlur and has an individual \"Save\" button\n   */\n  @action\n  handleSaveField(id: string, currentValue: FieldValue) {\n    const savePromise = this.saveField(id, currentValue);\n\n    if (!savePromise) {\n      return null;\n    }\n\n    return savePromise.then(() => {\n      this.setFieldState(id, 'showSave', false);\n    });\n  }\n\n  /**\n   * Cancel \"Save Field\" state and revert form value back to initial value\n   */\n  @action\n  handleCancelSaveField(id: string) {\n    this.setValue(id, this.initialData[id]);\n    this.setFieldState(id, 'showSave', false);\n  }\n\n  @action\n  setFieldState(id: string, key: string, value: FieldValue) {\n    const state = {\n      ...(this.fieldState.get(id) || {}),\n      [key]: value,\n    };\n    this.fieldState.set(id, state);\n  }\n\n  /**\n   * Set \"saving\" state for field\n   */\n  @action\n  setSaving(id: string, value: FieldValue) {\n    // When saving, reset error state\n    this.setError(id, false);\n    this.setFieldState(id, FormState.SAVING, value);\n    this.setFieldState(id, FormState.READY, !value);\n  }\n\n  /**\n   * Set \"error\" state for field\n   */\n  @action\n  setError(id: string, error: boolean | string) {\n    // Note we don't keep error in `this.fieldState` so that we can easily\n    // See if the form is in an \"error\" state with the `isError` getter\n    if (!!error) {\n      this.formState = FormState.ERROR;\n      this.errors.set(id, error);\n    } else {\n      this.formState = FormState.READY;\n      this.errors.delete(id);\n    }\n\n    // Field should no longer to \"saving\", but is not necessarily \"ready\"\n    this.setFieldState(id, FormState.SAVING, false);\n  }\n\n  /**\n   * Returns true if there are no errors\n   */\n  @action\n  validateForm(): boolean {\n    Array.from(this.fieldDescriptor.keys()).forEach(id => !this.validateField(id));\n\n    return !this.isError;\n  }\n\n  @action\n  handleErrorResponse({responseJSON: resp}: {responseJSON?: any} = {}) {\n    if (!resp) {\n      return;\n    }\n\n    // Show resp msg from API endpoint if possible\n    Object.keys(resp).forEach(id => {\n      if (\n        id === 'non_field_errors' &&\n        Array.isArray(resp.non_field_errors) &&\n        resp.non_field_errors.length\n      ) {\n        addErrorMessage(resp.non_field_errors[0], 10000);\n      } else if (Array.isArray(resp[id]) && resp[id].length) {\n        // Just take first resp for now\n        this.setError(id, resp[id][0]);\n      }\n    });\n  }\n\n  @action\n  submitSuccess(data: object) {\n    // update initial data\n    this.formState = FormState.READY;\n    this.initialData = data;\n  }\n\n  @action\n  submitError(err: {responseJSON?: any}) {\n    this.formState = FormState.ERROR;\n    this.formErrors = this.mapFormErrors(err.responseJSON);\n    this.handleErrorResponse({responseJSON: this.formErrors});\n  }\n\n  mapFormErrors(responseJSON?: any) {\n    return responseJSON;\n  }\n}\n\nexport default FormModel;\n","import React from 'react';\nimport InputField from 'app/views/settings/components/forms/inputField';\n\nexport default class TextField extends React.Component {\n  static propTypes = {\n    ...InputField.propTypes,\n  };\n\n  render() {\n    return <InputField {...this.props} type=\"text\" />;\n  }\n}\n","import {\n  addErrorMessage,\n  addLoadingMessage,\n  clearIndicators,\n} from 'app/actionCreators/indicator';\nimport {t} from 'app/locale';\n\n/**\n * Creates a new incident\n *\n * @param {Object} api API Client\n * @param {Object} organization Organization object\n * @param {String} title Title of the incident\n * @param {String[]} groups List of group ids\n */\nexport async function createIncident(api, organization, title, groups) {\n  addLoadingMessage(t('Creating new incident...'));\n\n  try {\n    const resp = await api.requestPromise(\n      `/organizations/${organization.slug}/incidents/`,\n      {\n        method: 'POST',\n        data: {\n          title,\n          groups,\n          query: '',\n        },\n      }\n    );\n    clearIndicators();\n    return resp;\n  } catch (err) {\n    addErrorMessage(t('Unable to create incident'));\n    throw err;\n  }\n}\n\n/**\n * Fetches a list of activities for an incident\n */\nexport async function fetchIncidentActivities(api, orgId, incidentId) {\n  return api.requestPromise(`/organizations/${orgId}/incidents/${incidentId}/activity/`);\n}\n\n/**\n * Creates a note for an incident\n */\nexport async function createIncidentNote(api, orgId, incidentId, note) {\n  try {\n    const result = await api.requestPromise(\n      `/organizations/${orgId}/incidents/${incidentId}/comments/`,\n      {\n        method: 'POST',\n        data: {\n          mentions: note.mentions,\n          comment: note.text,\n        },\n      }\n    );\n\n    return result;\n  } catch (err) {\n    addErrorMessage(t('Unable to post comment'));\n    throw err;\n  }\n}\n\n/**\n * Deletes a note for an incident\n */\nexport async function deleteIncidentNote(api, orgId, incidentId, noteId) {\n  try {\n    const result = await api.requestPromise(\n      `/organizations/${orgId}/incidents/${incidentId}/comments/${noteId}/`,\n      {\n        method: 'DELETE',\n      }\n    );\n\n    return result;\n  } catch (err) {\n    addErrorMessage(t('Failed to delete comment'));\n    throw err;\n  }\n}\n\n/**\n * Updates a note for an incident\n */\nexport async function updateIncidentNote(api, orgId, incidentId, noteId, note) {\n  try {\n    const result = await api.requestPromise(\n      `/organizations/${orgId}/incidents/${incidentId}/comments/${noteId}/`,\n      {\n        method: 'PUT',\n        data: {\n          mentions: note.mentions,\n          comment: note.text,\n        },\n      }\n    );\n    clearIndicators();\n    return result;\n  } catch (err) {\n    addErrorMessage(t('Unable to update comment'));\n    throw err;\n  }\n}\n\n// This doesn't return anything because you shouldn't need to do anything with\n// the result success or fail\nexport async function markIncidentAsSeen(api, orgId, incident) {\n  if (!incident || incident.hasSeen) {\n    return;\n  }\n\n  try {\n    await api.requestPromise(\n      `/organizations/${orgId}/incidents/${incident.identifier}/seen/`,\n      {\n        method: 'POST',\n        data: {\n          hasSeen: true,\n        },\n      }\n    );\n  } catch (err) {\n    // do nothing\n  }\n}\n"],"sourceRoot":""}