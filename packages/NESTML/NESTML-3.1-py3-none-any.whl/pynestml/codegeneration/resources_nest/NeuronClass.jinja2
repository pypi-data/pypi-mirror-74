{#
/*
*  NeuronClass.jinja2
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*/
#}
{%- if tracing %}/* generated by {{self._TemplateReference__context.name}} */{%- else -%}{%- endif -%}
/*
*  {{neuronName}}.cpp
*
*  This file is part of NEST.
*
*  Copyright (C) 2004 The NEST Initiative
*
*  NEST is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 2 of the License, or
*  (at your option) any later version.
*
*  NEST is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*
*  You should have received a copy of the GNU General Public License
*  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
*
*  {{now}}
*/

// C++ includes:
#include <limits>

// Includes from libnestutil:
#include "numerics.h"

// Includes from nestkernel:
#include "exceptions.h"
#include "kernel_manager.h"
#include "universal_data_logger_impl.h"

// Includes from sli:
#include "dict.h"
#include "dictutils.h"
#include "doubledatum.h"
#include "integerdatum.h"
#include "lockptrdatum.h"

#include "{{neuronName}}.h"

{% set stateSize = neuron.get_non_function_initial_values_symbols()|length %}
/* ----------------------------------------------------------------
* Recordables map
* ---------------------------------------------------------------- */
nest::RecordablesMap<{{neuronName}}> {{neuronName}}::recordablesMap_;

namespace nest
{
  // Override the create() method with one call to RecordablesMap::insert_()
  // for each quantity to be recorded.
  template <> void RecordablesMap<{{neuronName}}>::create(){
  // use standard names whereever you can for consistency!{% filter indent(2,True) %}
  {%- for variable in neuron.get_state_symbols() %}
    {%- include "directives/RecordCallback.jinja2" %}
  {%- endfor %}
  {%- for variable in neuron.get_initial_values_symbols() %}
    {%- include "directives/RecordCallback.jinja2" %}
  {%- endfor %}
  {%- for variable in neuron.get_internal_symbols() %}
    {%- include "directives/RecordCallback.jinja2" %}
  {%- endfor %}
  {%- for variable in neuron.get_parameter_symbols() %}
    {%- include "directives/RecordCallback.jinja2" %}
  {%- endfor %}
  {%- for odeAlias in neuron.get_ode_aliases() %}
    {%- with variable = odeAlias %}
      {%- include "directives/RecordCallback.jinja2" %}
    {%- endwith %}
  {%- endfor %}{% endfilter %}
  }
}

/* ----------------------------------------------------------------
 * Default constructors defining default parameters and state
 * Note: the implementation is empty. The initialization is of variables
 * is a part of the {{neuronName}}'s constructor.
 * ---------------------------------------------------------------- */
{{neuronName}}::Parameters_::Parameters_(){}

{{neuronName}}::State_::State_(){}

/* ----------------------------------------------------------------
* Parameter and state extractions and manipulation functions
* ---------------------------------------------------------------- */

{{neuronName}}::Buffers_::Buffers_({{neuronName}} &n):
  logger_(n)
{%- if neuron.get_multiple_receptors()|length > 1 -%}
  , spike_inputs_( std::vector< nest::RingBuffer >( SUP_SPIKE_RECEPTOR - 1 ) )
{%- endif -%}
{%- if useGSL -%}
  , __s( 0 ), __c( 0 ), __e( 0 )
{%- endif -%}
{
  // Initialization of the remaining members is deferred to
  // init_buffers_().
}

{{neuronName}}::Buffers_::Buffers_(const Buffers_ &, {{neuronName}} &n):
  logger_(n)
{%- if neuron.get_multiple_receptors()|length > 1 -%}
  , spike_inputs_( std::vector< nest::RingBuffer >( SUP_SPIKE_RECEPTOR - 1 ) )
{%- endif -%}
{%- if useGSL -%}
  , __s( 0 ), __c( 0 ), __e( 0 )
{%- endif -%}
{
  // Initialization of the remaining members is deferred to
  // init_buffers_().
}

/* ----------------------------------------------------------------
 * Default and copy constructor for node, and destructor
 * ---------------------------------------------------------------- */
{{neuronName}}::{{neuronName}}():Archiving_Node(), P_(), S_(), B_(*this)
{
  recordablesMap_.create();
  {%- if useGSL %}
  // use a default "good enough" value for the absolute error. It can be adjusted via `node.set()`
  P_.__gsl_error_tol = 1e-3;
  {%- endif %}

  {%- for parameter in neuron.get_parameter_non_alias_symbols() -%}
  {%- with variable = parameter %}
  {%- include "directives/MemberInitialization.jinja2" %}
  {%- endwith %}
  {%- endfor %}

  {%- for state in neuron.get_state_non_alias_symbols() -%}
  {%- with variable = state %}
  {%- include "directives/MemberInitialization.jinja2" %}
  {%- endwith %}
  {%- endfor %}

  {%- for init in neuron.get_initial_values_symbols() -%}
  {%- with variable = init -%}
  {%- include "directives/MemberInitialization.jinja2" %}
  {%- endwith %}{% endfor %}
}

{{neuronName}}::{{neuronName}}(const {{neuronName}}& __n):
  Archiving_Node(), P_(__n.P_), S_(__n.S_), B_(__n.B_, *this){
  {% for parameter in neuron.get_parameter_non_alias_symbols() -%}
    P_.{{names.name(parameter)}} = __n.P_.{{names.name(parameter)}};
  {% endfor %}
  {% for state in neuron.get_state_non_alias_symbols() -%}
    S_.{{names.name(state)}} = __n.S_.{{names.name(state)}};
  {% endfor %}
  {% for init in neuron.get_initial_values_non_alias_symbols() -%}
    S_.{{names.name(init)}} = __n.S_.{{names.name(init)}};
  {% endfor %}
  {% for internal in neuron.get_internal_non_alias_symbols() -%}
    V_.{{names.name(internal)}} = __n.V_.{{names.name(internal)}};
  {% endfor %}
}

{{neuronName}}::~{{neuronName}}(){ {% if useGSL %}
  // GSL structs may not have been allocated, so we need to protect destruction
  if (B_.__s)
    gsl_odeiv_step_free( B_.__s );
  if (B_.__c)
    gsl_odeiv_control_free( B_.__c );
  if (B_.__e)
    gsl_odeiv_evolve_free( B_.__e );{% endif %}
}

/* ----------------------------------------------------------------
* Node initialization functions
* ---------------------------------------------------------------- */

void {{neuronName}}::init_state_(const Node& proto){
  const {{neuronName}}& pr = downcast<{{neuronName}}>(proto);
  S_ = pr.S_;
}

{% if useGSL %}
{% include "directives/GSLDifferentiationFunction.jinja2" %}
{% endif %}

void {{neuronName}}::init_buffers_(){
  {% for buffer in neuron.get_input_buffers() -%}
  {{ printer.print_buffer_initialization(buffer) }}
  {% endfor %}
  B_.logger_.reset(); // includes resize
  Archiving_Node::clear_history();
  {% if useGSL %}
  if ( B_.__s == 0 ){
    B_.__s = gsl_odeiv_step_alloc( gsl_odeiv_step_rkf45, {{stateSize}} );
  } else {
    gsl_odeiv_step_reset( B_.__s );
  }

  if ( B_.__c == 0 ){
    B_.__c = gsl_odeiv_control_y_new( P_.__gsl_error_tol, 0.0 );
  } else {
    gsl_odeiv_control_init( B_.__c, P_.__gsl_error_tol, 0.0, 1.0, 0.0 );
  }

  if ( B_.__e == 0 ){
    B_.__e = gsl_odeiv_evolve_alloc( {{stateSize}} );
  } else {
    gsl_odeiv_evolve_reset( B_.__e );
  }

  B_.__sys.function = {{neuronName}}_dynamics;
  B_.__sys.jacobian = NULL;
  B_.__sys.dimension = {{stateSize}};
  B_.__sys.params = reinterpret_cast< void* >( this );
  B_.__step = nest::Time::get_resolution().get_ms();
  B_.__integration_step = nest::Time::get_resolution().get_ms();{% endif %}
}

void {{neuronName}}::calibrate(){
  B_.logger_.init();

  {%- for variable in neuron.get_internal_non_alias_symbols() %}
  {% include "directives/Calibrate.jinja2" %}
  {%- endfor %}

  {%- for variable in neuron.get_state_non_alias_symbols() -%}
  {%- if variable.has_vector_parameter() %}{% filter indent(2,True) %}
  {%- include "directives/Calibrate.jinja2" -%}{% endfilter -%}
  {%- endif -%}
  {%- endfor -%}

  {%- for buffer in neuron.get_input_buffers() -%}
    {%- if buffer.has_vector_parameter() -%}
        B_.{{buffer.get_symbol_name()}}.resize(P_.{{buffer.get_vector_parameter()}});
        B_.{{buffer.get_symbol_name()}}_grid_sum_.resize(P_.{{buffer.get_vector_parameter()}});
    {%- endif -%}
  {%- endfor %}
}

/* ----------------------------------------------------------------
* Update and spike handling functions
* ---------------------------------------------------------------- */

/*
 {{neuron.print_dynamics_comment('*')}}
 */
void {{neuronName}}::update(nest::Time const & origin,const long from, const long to){
  {% if useGSL -%}
  double __t = 0;
  {%- endif %}

  for ( long lag = from ; lag < to ; ++lag ) {
    {% for inputPort in neuron.get_input_buffers() -%}
    {% if inputPort.has_vector_parameter() %}
    for (long i=0; i < P_.{{inputPort.get_vector_parameter()}}; i++){
      B_.{{names.buffer_value(inputPort)}}[i] = get_{{names.name(inputPort)}}()[i].get_value(lag);
    }
    {% else -%}
    B_.{{names.buffer_value(inputPort)}} = get_{{names.name(inputPort)}}().get_value(lag);
    {% endif -%}
    {%- endfor -%}
    {%- set dynamics = neuron.get_update_blocks() -%}
    {%- with ast = dynamics.get_block() -%}{%- filter indent(2,True) -%}
    {%- include "directives/Block.jinja2" -%}{%- endfilter -%}
    {%- endwith %}
    // voltage logging
    B_.logger_.record_data(origin.get_steps()+lag);
  }

}

// Do not move this function as inline to h-file. It depends on
// universal_data_logger_impl.h being included here.
void {{neuronName}}::handle(nest::DataLoggingRequest& e){
  B_.logger_.handle(e);
}

{% for function in neuron.get_functions() -%}
{{printer.print_function_definition(function, neuronName)}}
{
  {%- with ast = function.get_block() -%}
  {%- include "directives/Block.jinja2" -%}
  {%- endwith -%}
}
{% endfor -%}

{% if is_spike_input %}
void {{neuronName}}::handle(nest::SpikeEvent &e){
  assert(e.get_delay_steps() > 0);
  {% if neuron.is_multisynapse_spikes() -%}
  {%- set spikeBuffer = neuron.get_spike_buffers()[0] -%}
  B_.{{spikeBuffer.get_symbol_name()}}[e.get_rport() - 1].add_value(
    e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin() ),
    e.get_weight() * e.get_multiplicity() );
  {%- elif neuron.get_multiple_receptors()|length > 1 -%}
  assert( e.get_rport() < static_cast< int >( B_.spike_inputs_.size() ) );

  B_.spike_inputs_[ e.get_rport() ].add_value(
    e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin() ),
    e.get_weight() * e.get_multiplicity() );
  {% else %}
  const double weight = e.get_weight();
  const double multiplicity = e.get_multiplicity();
  {% for buffer in neuron.get_spike_buffers() -%}
  {% if buffer.is_excitatory() %}
  if ( weight >= 0.0 ){ // excitatory
    get_{{buffer.get_symbol_name()}}().
        add_value(e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
                       weight * multiplicity );
  }
  {%- endif -%}
  {% if buffer.is_inhibitory() %}
  if ( weight < 0.0 ){ // inhibitory
    get_{{buffer.get_symbol_name()}}().
        add_value(e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
                      {% if buffer.is_conductance_based %} // ensure conductance is positive {% endif %}
                      {% if buffer.is_conductance_based %} -1 * {% endif %} weight * multiplicity );
  }
  {%- endif -%}
  {%- endfor %}
  {%- endif %}
}
{% endif -%}
{% if is_current_input %}
void {{neuronName}}::handle(nest::CurrentEvent& e){
  assert(e.get_delay_steps() > 0);

  const double current = e.get_current();		// we assume that in NEST, this returns a current in pA
  const double weight = e.get_weight();

  {%- for buffer in neuron.get_current_buffers() %}
  get_{{buffer.get_symbol_name()}}().add_value(
               e.get_rel_delivery_steps( nest::kernel().simulation_manager.get_slice_origin()),
               weight * current );
  {% endfor %}
}
{% endif %}
